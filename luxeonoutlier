# RebelPilot_STD.pl v1.74 -- RF
#    Will process each notHIDDEN WFR*.blu for each non-DW Rebel tile. Marks finished WFRs as HIDDEN.
#    Generates a complete set of output files.  This handles all but DW, ACLED, VEGA forms of Rebel

# TODO list:
# 1. fix Usage comments
# 2. Test against single color Rebel: e.g. MV1G, MS7G, etc. => DONE
# 4. Make sure this runs for Pre-Post Saber. => DONE
# 5. Move product-specific Vf/VfLow limit setting by DieBin into a new version       => DONE
#		of CheckLimits.pm and matching limit files, and make sure it (CheckLimits) is backward
#		compatible with old limits file version.  The new RebelPilot will require the new form.
# 6. Recently Pg site found that there is a problem of test reject mode is not matching between WFR file (suss tester) and syntricity.  => DONE
#	The defect mode we discover is :  WFR charged the reject units under �Low IV� code but syntricity charged it under �yellow tint�. 
#	Example of affected ID: i) MNC9EW2101107MA (Tile:100924-76J)
#	                        ii) MNC9EW101020MJ (Tile: 100913-67S)
# 7. Integrate Hikari into RebelPilot_STD
# 8. Add BinNum column next to PartID to match what the SAF program would produce.  Then we don't have to look up BinNumbers for a given catcode or reject code. => DONE
# 9. Query BlueDB for the MESLotID (see Siew email) for DataConnect compatibility.  Put in Header  => DONE
# 10.  Remove part number specific L0/L1part translation, i.e. MNC7F vs. MNC7F2, where the TesterType is the same  => DONE
# 11. Add EllipseBinning as an alternative to BoxBinning.  Must be able to do either during a run.  For Nozomi, first.  Include segment binning for outer ring.
# 12. Add command-line switch to disable BlueDB usage for off-line users.

# Usage: perl RebelPilot_STD.pl  [ ... with following command-line --options possible ]
#	--ProcMode=RAW  , default: RAW , processing modes are available: RAW
#   --SearchWith=FIND    # FIND or DIR method of finding unhidden WFR*.blu files, default: DIR
#	--WFRprefix=<R|P|nothing>, default: nothing>
#	--Import=<path of unprocessed WFR files directory top of tree, default: \\usbsjo91trmsLUM\TestData\L0\FwtReprocessing\WaferRaw\_Regan\MV1 >
#	--Export=<path of matching Export directory top, default: \\usbsjo91trmsLUM\TestData\L0\FwtReprocessing\Reprocessed\_Regan\MV1>
#	--Parts=<Top level directory of Parts directories, default: \\usbsjo91trmsLUM\TestData\L0\FwtReprocessing\Programs\Parts\>
#   --TesterPartsFile=<name of TesterParts file, without .txt, default:TesterParts>
#   --PartLinksFile=<name of PartLinks file, without .txt, default:PartLinks>
#	--LogDir=<Directory for writing MavPilotLog.txt, default: \\usbsjo91trmsLUM\TestData\L0\FWT\ScriptLogs>
#   --SkipIfOlder=<number of days WFR*.blu file age, will not process if older than>, default: 30
#	--PartialMaps="OK" or "notOK" allows for incomplete WFR*.blu to be reprocessed.  default: "notOK"
#   --VISmerge=YES      # YES or NO for merging VIS files, default: NO
#   --VISdir=\\usbsjo91trmsLUM\TestData\L0\Saber\Saber_Auto_Vis"; # where VIS files are, in a single pool
#   --VISprestep1=T390   # the step for the VIS, e.g. WFR060503-233-T390.vis, default: T390
#   --VISprestep2=T290   # the step for the VIS, e.g. WFR060503-233-T290.vis, default: NONE
#   --VISprestep3=T385   # the step for the VIS, e.g. WFR060503-233-T385.vis, default: NONE
#   --VISpoststep=T5302  # the final step for the WFR, e.g. WFR060503-233-T490_1000.blu, default: "NONE"
#   --VISlist=SaberVisList.txt # a file in VISdir that has full path of any matching .VIS files under VISdir
#   --SingleWhiteBin=NO      # YES or NO for merging all white bins into one xx colorbin, default: NO
#   --TRM_STmaps=YES  # YES or NO means a TRM_ST will/will not be generated to the proc folder. default:NO
#   --CVF_report=YES # YES or NO means a CVF_<tileID>.txt will/won't be generated to the proc folder. default:NO
#   --LMWbinning=YES ; default is NO
#   --Summaries=NO; default is YES  # will skip the generation of WFS,WHY,WFZ,DPS,DPM files. Keep WFR,TSM,TSS
#   --BinOption=IGZ ; default is STD # will be added per die in BinOption field.  Future use is to flag which are STD for L2 Binning.
#   --BinDefs=MULTI ; default is SINGLE means only one def for bin codes;
#                    MULTI means we can have more than 1 set of limits for a code,
#                    or overlapping limits for different codes 
#	"ODBCname=s" => \$ODBCname,
#	"ODBCpassword=s" => \$ODBCpassword,
#	"WFRRawFile=s" => \$WFRRawFile,
#	"PBVfFilter=s" => \$PBVfFilter );
#    --PostSaberfolder
#    --FWTpostest =T390_700.blu ; default is T390_350.blu

use strict;
#use warnings;

use Win32::File;
use File::Find();
use File::Copy;
require File::Spec;
use Win32::ODBC;
use Net::SMTP;

use lib qw( . .. ..\Modules .\Modules); # add to module search path
use RawChopper 1.0 qw(:DEFAULT );
use PartLinks 1.0;
#use BinnerVf 1.3;
use BinnerVf 1.6;
use CheckLimits 1.2;
use ProductStructure 2.0 qw(:DEFAULT %Align2AlignRC);
use TesterParts2 2.1;
use StatisticsLite qw(:funcs);  # must be in app directory
use Getopt::Long;
use BoxBinner 1.0;
use EllipseBinner 2.0;  # needed for products that require elliptical binning, like Nozomi
use ProgramInit 1.0;
#our $VersionHeader = "Program: RebelPilot_STD.pl 1.78\nModules: RawChopper 1.0; PartLinks 1.0; BinnerVf 1.3; CheckLimits 1.6; ProductStructure 2.0; TesterParts2 2.1; BoxBinner 1.0; EllipseBinner 2.0; ProgramInit 1.0;\n";
our $VersionHeader = "Program: RebelPilot_STD.pl 1.78\nModules: RawChopper 1.0; PartLinks 1.0; BinnerVf 1.6; CheckLimits 1.6; ProductStructure 2.0; TesterParts2 2.1; BoxBinner 1.0; EllipseBinner 2.0; ProgramInit 1.0;\n";

print $VersionHeader;

# The global working variables for this program, not scoped to any other modules
our ($FullWFRpath, $FullWFRdir,$Part);
our (%ProductBinCounts, @PartID, @BinStatus, $TotalGoodDie, $ActualTested); 
our (%LimitRejCounts, %ColorRejCounts, %IvRejCounts, %LightRejCounts);  # Reject counter hashes
our ($PartLink, $FileWafID, $WaferID);  # set in SetProductType()
our ($die, $arr, @dieset, $fieldname, $attrib, $binstat, $numdierecs, $numArrayLeds); # working temporary variables
our $TesterType;  # the value pulled in from the WFR*.blu "Type" field.  Can get modified if it contains *-1M* for multi-current types
our $Iforce; # The primary forcing current value for this WFR*.blu.  Extracted from the filename.
our $DieBin;
our ($TotalYield, $YieldBasis, $NoSaberYield);
our ($BinColorName, $BinIntensityName);  # names of the binning variables, fetched from *Bins.txt file
our $RawLotName;      # Just the lot name, no additional path
our $YieldSummaryRec; # holds the most recently generated yield summary 2-line record
our $WFR1;            # global RawChopper object(s)
our $WFZRpt;          # items for the parametric statistics summary.
our $binspath;        # current path for the *Bins.txt  spec file
our (%PnPBinCounts, %PnPPartIDs);
our (%TsmBinCounts, %TsmPartIDs);
our ($VISready, %VisRejCounts, $VISwaferid, $MergeVISproduct, $TotalVISrej); # Working VIS merge variables
our %VIS_score = ();  # tally a score for all the VISmerge steps for each $aRow_$aCol to decide what to set VISflag in the WFR

# defined for Maverick products in TesterParts2 table
our ($L0Part, $L1Part, $OptionCodes, $BinStructure, $LED, $Phosphor, $IsProduct, $Calibrated, $Color, $WhiteType, $RadioPhoto, $LedsPerLamp);
our ($EpoxyFlag ,$FWTflag ) ;
our $BoxBinning = 1;          # set to 1 if BasePartName is for a White part, else 0.
our $EllipseBinning = 0;          # set to 1 if BasePartName is for a Ellipse-binned part, else 0.
our %VIS2path = ();    # lookup table keyed by VIS filename, value is full path of file
sub InitVisList();  # declare function prototype before using early in program
sub WantedDirWFR(); # ditto
our @WFRlist;       # when SearchWith=DIR, then the pathlist of WFR*.blu files to work on is in this array.
our $WFRname;
our $SaberLotID;
our $SubmountID = "";
our $MESLotID = ""; # will be set by GetMESLotID for each tile
our $rdx=0;
our $bluedb;
our	$Vf_x_uA_name = "Vf_10_uA"; # or Vf_20_uA is set for each tile
our	$Vf_x_uA_value = ();
our %VfTable = ();  # items used by %VfTable setup
our $ProductFamily = "";
our $TempTC = "";
our $RxType = "";
our $DieBinGroup = ();
sub GetDieBinGroup($);
our (@PHIvset, $PHIv, $PHIv_Mean, $PHIv_Stdev, $PHIv_USL, $PHIv_LSL, %PHIv_LSL, $PHIv_reject);
our ($PHIvOutlierCounts);
our %RejParetoCounts;
our (@Vf2set, $Vf2, $Vf2_Mean, $Vf2_Stdev, $Vf2_USL, $Vf2_LSL, %Vf2_LSL, $Vf2_reject,$Vf2_Mode);
our ($Vf2OutlierCounts);
our (@Vf_x_uA_set, $Vf_x_uA, $Vf_x_uA_Mean, $Vf_x_uA_Stdev, $Vf_x_uA_USL, $Vf_x_uA_LSL, %Vf_x_uA_LSL, $Vf_x_uA_reject);
our ($Vf_x_uA_OutlierCounts);


# Set command line argument defaults, can override any in any order with above command line --options
our $ProcessingMode = "RAW";
our $SearchWith ='DIR';
our $TopDir = "\\\\MYGBYNBYN1ms006\\DFTEST\\L0\\FWT\\Programs\\BetaTest\\Rebel\\Ling\\Raw\\LuxF";
our $ExportsDir = "\\\\MYGBYNBYN1ms006\\DFTEST\\L0\\FWT\\Programs\\BetaTest\\Rebel\\Ling\\Proc\\LuxF";
our $PartsDir = "\\\\MYGBYNBYN1ms006\\DFTEST\\L0\\FWT\\Programs\\Parts\\";  # must have the trailing \ in the path to work
our $TesterPartsFile = "LuxF-TesterParts";  # do not add the .txt file extension
our $PartLinksFile = "LuxF-PartLinks";      # do not add the .txt file extension
our $PartialMaps = "notOK";
our $WFRprefix="";  # letter prefix optionally pre-pended to the substrateID determines which WFRs will get processed.
our $VISmerge = "YES"; # YES or NO for any merging of VIS files, but is combined with $MergeVISproduct
our $VISdir = "\\\\mygbynbyn1msna2\\Saber\\Saber_Auto_Vis"; # where VIS files are stored in lot folders
our $EPprestep = "T190.FWD";
our $FWTpostest = "T390_350.blu";
our $VISprestep1 = "T390";    # the step for the VIS, e.g. WFR060503-233-T390.vis
our $VISprestep2 = "T490";    # the step for the VIS number 2
our $VISprestep3 = "T590";    # the step for the VIS number 3
our $VISprestep4 = "T520";    # the step for the VIS number 4
our $VISpoststep = "NONE"; #"T490";   # the step for the WFR, e.g. WFR060503-233-T490_1000.blu
our $VisList = "SaberCEList.txt";  # name of previously generated VISdir directory listing created with cd VisDir; dir /b /s *T390.vis > thelistname.txt
our $SingleWhiteBin = "NO"; # if YES, all white color bins will be lumped into a single partID colorbin xx
our $LogDir = "\\\\MYGBYNBYN1ms006\\DFTEST\\L0\\FWT\\Programs\\BetaTest\\brinz\\log";  # default errlog folder
our $SkipIfOlder = 30; # Will not process any WFR*.blu older than this many days
our $TRM_STmaps = "NO";  # Enable/Disable TRM_ST maps (same format as final Rebel Tile Smart Sorter pnp maps)
our $CVF_report = "NO";  # Enable/Disable CVF report
our $LMWbinning = "NO";  # if YES will override pass parts with FAIL if LMW calculation is Less Than 100.
our $Summaries="YES"; # if NO will prevent generation of WHY,WFS,WFZ,DPS,DPM. Keep WFR,TSM,TSS reports.
our $BinOption="STD"; # or other special BinOptions like LMW, IGZ, ANS 
our $Conversion_Efficiency = "YES"; # Enable/disable for CE
our $BinDefs = 'SINGLE'; # else MULTI  or SINGLE
our $PBVfFilter="YES"; #If YES ,Pump Bin Filtering for Janus and Fontus part
our $WFRRawFile  = "";
our $PostSaberfolder = "\\\\mygbynbyn1msna2\\TESTDATA\\L0\\Raw\\Wafer\\Saber\\";
our $ODBCname = "BlueDB";
#our $ODBCpassword = "joy4all";  # for SG/SJ, joy4all for PG
our $ODBCpassword = "Icec00l2";  # for SG/SJ, joy4all for PG
our $xLotPartPrefix21 = "21";
our $xLotPartPrefix31 = "31";
our $xLotPartPrefix41 = "41";
our $xLotPartPrefix51 = "51";
our $trn;
#our $BurnDir = "\\\\mygbynbyn1msna2\\SABER\\BurnIn\\LUXEONF\\";
#our $BurnDir = "\\\\mygbynbyn1msna2\\SABER\\BurnIn\\LUXEONF_OLD\\";
our $BurnDir = "\\\\MP2DO4CE0373NDX\\Mygbynbyn1ms006_V1\\Saber\\Archive_BurnIn\\LUXEONF\\";



# This will fetch any defined --options on the command-line.  Spelling and case matters.
GetOptions(
	"ProcMode=s" => \$ProcessingMode,  # "RAW"
	"SearchWith=s" => \$SearchWith,
	"Import=s" => \$TopDir,
	"Export=s" => \$ExportsDir,
	"WFRprefix=s" => \$WFRprefix,
	"ODBCname=s" => \$ODBCname,
	"ODBCpassword=s" => \$ODBCpassword,
	"Parts=s" => \$PartsDir,
	"TesterPartsFile=s" => \$TesterPartsFile,
	"PartLinksFile=s" => \$PartLinksFile,
	"LogDir=s" => \$LogDir,
	"SkipIfOlder=s" => \$SkipIfOlder,
	"PartialMaps=s" => \$PartialMaps,
	"TRM_STmaps=s" => \$TRM_STmaps,
	"Summaries=s" => \$Summaries,
	"BinOption=s" => \$BinOption,
	"CE=s" => \$Conversion_Efficiency,
	"CVF_report=s" => \$CVF_report,
	"LMWbinning=s" => \$LMWbinning,
	"BinDefs=s" => \$BinDefs,
	"VISmerge=s" => \$VISmerge,
	"VISdir=s" => \$VISdir,
	"VISlist=s" => \$VisList,
	"EPprestep=s" => \$EPprestep,      #Epoxy width measurement merging
	"FWTpostest=s" => \$FWTpostest, 
	"VISprestep=s" => \$VISprestep1,   # for backward compatibility with existing scripts
	"VISprestep1=s" => \$VISprestep1,
	"VISprestep2=s" => \$VISprestep2,
	"VISprestep3=s" => \$VISprestep3,
	"VISprestep4=s" => \$VISprestep4,
	"VISpoststep=s" => \$VISpoststep,
	"SingleWhiteBin=s" => \$SingleWhiteBin,
	"WFRRawFile=s" => \$WFRRawFile,
	"PBVfFilter=s" => \$PBVfFilter,
	"PostSaberfolder=s" => \$PostSaberfolder);

# Collect bad file info or other die exceptions
# Global signal __DIE__
$SIG{__DIE__} = sub { print LOG @_; };

my $LogPath = $LogDir."\\RebelPilot_STD_Log.txt";
open(LOG, ">>$LogPath")|| die "Can't write $LogPath!\n";
my $LogPathNP = $LogDir."\\NotProcessedRebelPilot_STD_Log.txt";
open(LOGNP, ">>$LogPathNP")|| die "Can't write $LogPathNP!\n";
my $now = localtime time;
print LOG "Beginning $now\n";
print LOG "$VersionHeader\n";
print LOG "Current ProcessID = $$\n";
print  "Beginning $now\n";
print  "$VersionHeader\n";
print  "Current ProcessID = $$\n";

PartLinks::InitPartLinksFile($PartsDir,$PartLinksFile); # only need to do this once
TesterParts2::InitTesterPartsFile($PartsDir,$TesterPartsFile);

# $bluedb = new Win32::ODBC("DSN=$ODBCname;UID=BlueRD;PWD=$ODBCpassword");
$bluedb = new Win32::ODBC("DSN=$ODBCname;UID=BlueDB;PWD=$ODBCpassword");
if(!$bluedb)
{
	die "Error connecting to BlueDB: ".Win32::ODBC::Error()."\n";
	return 0;
}
print "$ODBCname is connected\n";

# for the convenience of &wanted calls, including -eval statements:
use vars qw/*name *dir *prune/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;


# SIEWTY: Enabling selected single file processing
if ($WFRRawFile ne "")
{
	@WFRlist = $WFRRawFile;
	my ($volume,$wfrdir,$wfrfile) = File::Spec->splitpath(@WFRlist);
	chop $wfrdir;
	$FullWFRpath = $WFRRawFile;
	$FullWFRdir = $volume.$wfrdir;
	$WFRname = $wfrfile;

	print "WFRRawFile = $WFRRawFile\n";

	WantedDirWFR();
}
elsif($ProcessingMode =~ /^(RAW)$/i && $SearchWith eq 'FIND')
{
	print "Searching for unHidden WFR*.blu to process with File::Find::find\n";
	# Traverse desired filesystem(s)
	# Everytime it finds a file, that filename will be passed to the wanted() sub.
	File::Find::find({wanted => \&WantedWFR}, $TopDir);
	# does not return until it has finished traversing the entire directory and all subdirs.
}
elsif($ProcessingMode =~ /^(RAW)$/i && $SearchWith eq 'DIR')
{
	# This SearchWith mode uses the windows command dir to find all the unHidden WFR*.blu files faster than the Find method does
	print "Searching for unHidden WFR*.blu to process with DIR /b /s listing\n";
	my $StartDir = localtime time;
	print "Begin Search...$StartDir\n\n";
	my $dircmd = "dir /b /o-d /s $TopDir\\WFR*.blu";
	@WFRlist = `$dircmd`;  # `back-ticks` cause an external program to run and return the results to the array.
	
	if (scalar @WFRlist == 0)
	{
		print "No unHidden WFR*.blu files found in $TopDir and subdirs\n";
	}
	else
	{
		print "Found the following WFR*.blu to process:\n";
		print @WFRlist;
		chomp @WFRlist;
		
		my $EndDir = localtime time;
		print "\nEnd Search...\n$EndDir\n\n";
		
		my $StartProc = localtime time;
		print "Begin Processing...\n";
		print "$StartProc\n";
		
		foreach my $wfrpath (@WFRlist)
		{
			my ($volume,$wfrdir,$wfrfile) = File::Spec->splitpath($wfrpath);
			$FullWFRpath = $wfrpath;
			chop $wfrdir;
			$FullWFRdir = $volume.$wfrdir;
			$WFRname = $wfrfile;
			WantedDirWFR();
		}
		
		my $EndProc = localtime time;
		print "End Processing...\n";
		print "$EndProc\n\n";
	}
}
else
{
	print "ProcMode $ProcessingMode and/or SearchWith $SearchWith Not Valid!\n";
}

$now = localtime time;
$bluedb->Close();  # be nice and clean up database connection
print LOG "Ending $now\n";
close LOG;
close LOGNP;

exit;
#-----------------------------------------------------------------------------

sub WantedDirWFR()
{
	# $WFRname, $FullWFRpath, $FullWFRdir have been pre-set instead of being passed as an argument to mimic File::Find:find
	if($WFRname =~ /^WFR$WFRprefix.*\.blu\z/si)  # ignores case
	{ # $_ is set to the WFR basename, which is what the above pattern match is working on
		# Examine file attributes for processing decision
		chdir $FullWFRdir;

		# SIEWTY: If selected single file processing, then don't hide the RAW file
		if ($WFRRawFile eq "")
		{
			Win32::File::GetAttributes($FullWFRpath, $attrib);
			if( $attrib & HIDDEN || (-M $FullWFRpath > $SkipIfOlder) )
			{
				#print "Skipping $FullWFRpath\n";
				return  0;
			}
		}
		my @pathparts = File::Spec->splitdir($FullWFRdir);# will split a directory path into its various parts
		$RawLotName = uc $pathparts[-1];
		my $file = $WFRname;
		$file =~ s/^WFR$WFRprefix//i;  # remove WFR prefix from filename
		$file =~ s/\.blu//i; # remove .blu file extension
		$file =~ s/ //g;     # remove any embedded spaces
		$file =~ s/_/-/g;    # change underscore characters to hyphen
		$file =~ s/^[rR]//g;  # remove any leading r's (if WFRprefix is "" but someone entered R prefix anyway)
		$FileWafID = $file;
		#print "Rawmode lot name= $RawLotName, WaferID= $FileWafID\n";
		if(ProcessWFR())
		{ # if no error, set HIDDEN attribute for file
			Win32::File::SetAttributes($FullWFRpath, $attrib | HIDDEN);
		}
		else
		{
			print "\n****INCOMPLETE PROCESSING for $FullWFRpath!****\n\n";
		}
		undef $WFR1; # reset the main RawChopper object
	}
}

sub WantedWFR()
{
	if(/^WFR$WFRprefix.*\.blu\z/si)  # ignores case
	{ # $_ is set to the WFR basename, which is what the above pattern match is working on
		# and we have been chdir'ed to $dir
		$FullWFRpath = $name;
		$FullWFRdir = $dir;
		# Examine file attributes for processing decision
		Win32::File::GetAttributes($FullWFRpath, $attrib);
		if( $attrib & HIDDEN || (-M $FullWFRpath > $SkipIfOlder) )
		{
			#print "Skipping $FullWFRpath\n";
			return  0;
		}
		my @pathparts = File::Spec->splitdir($dir);# will split a directory path into its various parts
		$RawLotName = uc $pathparts[-1];
		my ($volume,$directories,$file) = File::Spec->splitpath($name);
		$file =~ s/^WFR$WFRprefix//i;  # remove WFR prefix from filename
		$file =~ s/\.blu//i; # remove .blu file extension
		$file =~ s/ //g;     # remove any embedded spaces
		$file =~ s/_/-/g;    # change underscore characters to hyphen
		$file =~ s/^[rR]//g;  # remove any leading r's (if WFRprefix is "" but someone entered R prefix anyway)
		$FileWafID = $file;
		#print "Rawmode lot name= $RawLotName, WaferID= $FileWafID\n";
		if(ProcessWFR())
		{ # if no error, set HIDDEN attribute for file
			Win32::File::SetAttributes($FullWFRpath, $attrib | HIDDEN);
		}
		else
		{
			print "\n****INCOMPLETE PROCESSING for $FullWFRpath!****\n\n";
		}
		undef $WFR1; # reset the main RawChopper object
	}
}

sub ResetCounters # ()
{ # reset for each WFR processed
	$TotalGoodDie = 0;
	$ActualTested = 0;
	$TotalVISrej = 0;
	%ProductBinCounts = ();
	%ColorRejCounts = ();
	%IvRejCounts = ();
	%LightRejCounts = ();
	%LimitRejCounts = ();
	%VisRejCounts = ();
	@BinStatus = ();
	@PartID = ();
}

sub SetProductType # ()
{	# Initialize module variables for the current WFR, and initializes supporting modules
	# extract Type field used as best indicator of product type
	if( $WFR1->HeaderFieldExists("Type"))
	{
	   $TesterType = uc $WFR1->GetHeaderField("Type","");
	}
	else
	{
		print LOG "No TYPE header field in $FullWFRpath\n";
		print  "No TYPE header field in $FullWFRpath\n";
		return 0;
	}
	$TesterType =~ s/\.WST//gi;  # strip the trailing .WST extension if there
	print "Original TesterType: $TesterType\n";
	# Use the TesterType to PartLink conversion tables located in TesterParts2.pm
	# modify the general Type name for the proper drive condition based on Iforce value
	#  which is obtained from the FileWafID
	my @temp = split("\-",$FileWafID);
	my $fileIforce = $temp[-1];
	$TesterType =~ s/\-1M/\-$fileIforce/gi;


	print "Revised TesterType: $TesterType\n";
	$PartLink = TesterParts2::GetPartLink($TesterType);
	if($PartLink eq	"") # unknown $TesterType type
	{
		$PartLink = "";
		$L0Part = "";
		print "Unknown TesterType $TesterType, can't determine PartLink, HIDEing...\n";
		Win32::File::SetAttributes($FullWFRpath, $attrib | HIDDEN);
		print LOG "Unknown TesterType $TesterType for $FullWFRpath! HIDEing...\n";
		print LOGNP "Unknown TesterType $TesterType for $FullWFRpath! HIDEing...\n";
		return 0;  # early exit
	}
	# FIXME: We can no longer force a fixed partlink or L0 part beccause so much required
	#  info comes from the TesterParts2 tables. We could force a fixed testertype.
	$L0Part = TesterParts2::GetL0Part($TesterType);
	$L1Part = TesterParts2::GetL1Part($TesterType);
	$MergeVISproduct = TesterParts2::GetMergeVIS($TesterType);
	$Iforce = TesterParts2::GetIforce($TesterType);
	if($Iforce ne $fileIforce)
	{
		print "TesterParts table Iforce $Iforce does not match fileIforce $fileIforce\n";
		print LOG "TesterParts table Iforce $Iforce does not match fileIforce $fileIforce\n";
		print LOGNP "TesterParts table Iforce $Iforce does not match fileIforce $fileIforce for $FullWFRpath\n";
		return 0;
	}
	$OptionCodes = TesterParts2::GetOptionCodes($TesterType);
	$BinStructure = TesterParts2::GetBinStructure($TesterType);
	$LED = TesterParts2::GetLED($TesterType);
	$Phosphor = TesterParts2::GetPhosphor($TesterType);
	$IsProduct = TesterParts2::GetIsProduct($TesterType);   
	$ProductFamily = TesterParts2::GetCalibrated($TesterType);  # TEMPORARILY HIJACKED in TesterParts2 for assigning $ProductFamily that is used with VfTable naming
	$Color = TesterParts2::GetColor($TesterType);
	$WhiteType = TesterParts2::GetWhiteType($TesterType);
	$RadioPhoto = TesterParts2::GetRadioPhoto($TesterType);
	$LedsPerLamp = TesterParts2::GetLedsPerLamp($TesterType);

	# Clear the part property flags, then set according to TesterParts table values
	$BoxBinning = 1;
	$EllipseBinning = 0;  # we will determine whether is also Ellipse Binning by table name for now.
	
	if($Color =~ /^(White|BoxBin).*/i)
	{
		$BoxBinning = 1;
	}

	# Override the default L0, L1 partnumbers with special version extracted from LotName prefix, if it exists
	#  This is being done because all M*2<YYMMDDss> lot names use the same TesterType as M*<YYMMDDss>,
	#  making this the only way we can set the PartID correctly.  How lame!  Could also be M*n<YYMMDDss>, but not M*1
	#print "$RawLotName\n";

	# The regular expression way, without being Part specific, expires after 2019 
	my @L0PartPieces = split('-', $L0Part);
	my $L0PartPrefix = $L0PartPieces[0];
	my @L1PartPieces = split('-', $L1Part);
	my $L1PartPrefix = $L1PartPieces[0];

	#print "Test = $L0PartPrefix$xLotPartPrefix21\n";

	if($RawLotName =~ /^$L0PartPrefix$xLotPartPrefix21.*/)
	{
		$L0Part = $L0PartPrefix."2-2";
		$L1Part = $L1PartPrefix."2-2";
	}
	elsif($RawLotName =~ /^$L0PartPrefix$xLotPartPrefix31.*/)
	{
		$L0Part = $L0PartPrefix."3-2";
		$L1Part = $L1PartPrefix."3-2";
	}
	elsif($RawLotName =~ /^$L0PartPrefix$xLotPartPrefix41.*/)
	{
		$L0Part = $L0PartPrefix."4-2";
		$L1Part = $L1PartPrefix."4-2";
	}
	elsif($RawLotName =~ /^$L0PartPrefix$xLotPartPrefix51.*/)
	{
		$L0Part = $L0PartPrefix."5-2";
		$L1Part = $L1PartPrefix."5-2";
	}

#	if($RawLotName =~ /^$L0PartPrefix\21.*/)
#	{
#		$L0Part = $L0PartPrefix."2-2";
#		$L1Part = $L1PartPrefix."2-2";
#	}
#	elsif($RawLotName =~ /^$L0PartPrefix\31.*/)
#	{
#		$L0Part = $L0PartPrefix."3-2";
#		$L1Part = $L1PartPrefix."3-2";
#	}
#	elsif($RawLotName =~ /^$L0PartPrefix\41.*/)
#	{
#		$L0Part = $L0PartPrefix."4-2";
#		$L1Part = $L1PartPrefix."4-2";
#	}
#	elsif($RawLotName =~ /^$L0PartPrefix\51.*/)
#	{
#		$L0Part = $L0PartPrefix."5-2";
#		$L1Part = $L1PartPrefix."5-2";
#	}

	print "Processed with: RawLotName = $RawLotName, PartLink= $PartLink, L0Part= $L0Part, L1Part= $L1Part, L0PartPrefix=$L0PartPrefix\n";
# Start generating a partfile summary for this lot.  There should only be one file created per lot 
	#  if they are all the same testertype.  First write it all to a generic file, then generate the CRC,
	#  then copy the generic to a file with the CRC in the name.  If there is a change in the CRC
	#  for any reason, then there will be 2 or more summaries per lot.  Which setup was used
	#  is noted in the proc WFR*.blu header field PartsSummary_CRC.  Wafer-specific settings like
	#  ..., etc. are not included.  Many lots can have the same PartsSummary_CRC.txt
  
	my $rptdir = "$ExportsDir/$RawLotName";
	mkdir $rptdir || die "Can't create directory $ExportsDir/$RawLotName\n";
	my $PartsSummaryPath = "$rptdir\\PartsSummary_temp.txt";
	open(PARTSUMMARY, ">$PartsSummaryPath") or die "Can't create $PartsSummaryPath\n";
	print PARTSUMMARY "BEGIN_MODES\n";
	print PARTSUMMARY "TesterPartsFile: $TesterPartsFile\n";
	print PARTSUMMARY "PartLinksFile: $PartLinksFile\n";
	print PARTSUMMARY "TesterType: $TesterType\n";
	print PARTSUMMARY "PartLink: $PartLink\n";
	print PARTSUMMARY "L0Part: $L0Part\n";
	print PARTSUMMARY "L1Part: $L1Part\n";
	# add run time processing modes
	print PARTSUMMARY "PartsDir: $PartsDir\n";
	print PARTSUMMARY "RawDir: $TopDir\n";
	print PARTSUMMARY "ProcDir: $ExportsDir\n";
	print PARTSUMMARY "PartialMaps: $PartialMaps\n";
	print PARTSUMMARY "ODBCname: $ODBCname\n";
	print PARTSUMMARY "SkipIfOlder: $SkipIfOlder";
	print PARTSUMMARY "PartialMaps: $PartialMaps";
	print PARTSUMMARY "TRM_STmaps: $TRM_STmaps";
	print PARTSUMMARY "Summaries: $Summaries";
	print PARTSUMMARY "BinOption: $BinOption";
	print PARTSUMMARY "CE: $Conversion_Efficiency";
	print PARTSUMMARY "CVF_report: $CVF_report";
	print PARTSUMMARY "LMWbinning: $LMWbinning";
	print PARTSUMMARY "BinDefs: $BinDefs";
	print PARTSUMMARY "VISmerge: $VISmerge";
	print PARTSUMMARY "VISdir: $VISdir";
	print PARTSUMMARY "VISprestep1: $VISprestep1";
	print PARTSUMMARY "VISprestep2: $VISprestep2";
	print PARTSUMMARY "VISprestep3: $VISprestep3";
	print PARTSUMMARY "VISpoststep: $VISpoststep";
	print PARTSUMMARY "EPprestep: $EPprestep";      #Epoxy width measurement merging
	print PARTSUMMARY "FWTpostest: $FWTpostest"; 
	print PARTSUMMARY "SingleWhiteBin: $SingleWhiteBin";
	print PARTSUMMARY "ProcSingleWFR: $WFRRawFile";
	print PARTSUMMARY "PostSaberfolder: $PostSaberfolder";
	# Product-specific modes and settings
	print PARTSUMMARY "MergeVISproduct: $MergeVISproduct\n";
	print PARTSUMMARY "Iforce: $Iforce\n";
	print PARTSUMMARY "OptionCodes: $OptionCodes\n";
	print PARTSUMMARY "BinStructure: $BinStructure\n";
	print PARTSUMMARY "LED: $LED\n";
	print PARTSUMMARY "Phosphor: $Phosphor\n";
	print PARTSUMMARY "IsProduct: $IsProduct\n";
	print PARTSUMMARY "ProductFamily: $ProductFamily\n"; # Calibrated TEMPORARILY HIJACKED for assigning $ProductFamily that is used with VfTable naming
	print PARTSUMMARY "Color: $Color\n";
	print PARTSUMMARY "WhiteType: $WhiteType\n";
	print PARTSUMMARY "RadioPhoto: $RadioPhoto\n";
	print PARTSUMMARY "LedsPerLamp: $LedsPerLamp\n";
	

	# extract the $WaferID
	my $tempid = $WFR1->GetHeaderField('%Wafer',"");
	$WaferID = substr($tempid,1);  # remove leading % sign (which is a comment delimiter for Matlab)
	# Get WaferID from File
	my $tempFileWafID = $FileWafID;
	$tempFileWafID =~ s/-Tj(25|85|86)//g;
	$tempFileWafID =~ s/-$Iforce//g;
	
	if($WaferID eq "")
	{
		print "WaferID is blank!\n";  # We don't want to process wafers with no WaferID
		print LOG "WaferID is blank for $FullWFRpath!\n";  # We don't want to process wafers with no WaferID
		print LOGNP "WaferID is blank for $FullWFRpath!\n";  # We don't want to process wafers with no WaferID
		return 0;
	}
	elsif ($tempFileWafID !~ /^$WaferID/) # Match Test Header Data "%Wafer" to File Wafer ID - Victor 17Feb'16
	{
		print "%WaferID $WaferID does not match File WaferID $tempFileWafID for $FullWFRpath!\n";  # We don't want to process wafers with wrong WaferID
		print LOG "%WaferID $WaferID does not match File WaferID $tempFileWafID for $FullWFRpath!\n";  # We don't want to process wafers with wrong WaferID
		print LOGNP "%WaferID $WaferID does not match File WaferID $tempFileWafID for $FullWFRpath!\n";  # We don't want to process wafers with wrong WaferID
		return 0;
	}
	else
	{
		#print "WFR internal $WaferID not the same as file WaferID $FileWafID! Changing internal ...\n";
		if(!GetDieBin($WaferID))
		{
			print     "No TileDieBin available for $FullWFRpath!\n";  
			print LOG "No TileDieBin available for $FullWFRpath!\n";  
			print LOGNP "No TileDieBin available for $FullWFRpath!\n";  
			return 0;  # global variable $DieBin is set using BlueDB info
		}
		$VISwaferid = $WaferID;
		$WaferID = $FileWafID;
		$WFR1->ReplaceHeaderField('%Wafer',"\%".$WaferID, ""); # the leading percent sign retained
	}

	# Initialize the correct Limits, Bins, and ProductStructure for this product
	$binspath = PartLinks::GetPartBinsPath($PartLink);
	BinnerVf::InitBinner($binspath);
	CheckLimits::InitCheckLimits( PartLinks::GetPartLimitsPath($PartLink));
	ProductStructure::InitProductStructure( PartLinks::GetPartStructurePath($PartLink));

	if( $BoxBinning == 1)
	{   # assumes anything using boxbinning has properly identified the boxbindefs file
		#  in the ..Bins.txt file and placed it in the $PartsDir folder
		my $BoxBinDefs = BinnerVf::GetBinHeaderField("BoxBinDefs");
		if($BoxBinDefs =~ /Ellipse/i)  # needs to have word Ellipse in filename, i.e. NozomiEllipseBins.txt
		{
			EllipseBinner::InitEllipseBinner("$PartsDir/$BoxBinDefs\.txt");
			print "Using $BoxBinDefs for Ellipse Binning Definitions\n";
			$EllipseBinning = 1;
		}
		else
		{
			BoxBinner::InitBoxBinner("$PartsDir/$BoxBinDefs\.txt");
			print "Using $BoxBinDefs for Box Binning Definitions\n";
			$EllipseBinning = 0;
		}
	}

	$WFR1->AddHeaderField("VfLowPostLimit","ReprocSpec");
	$WFR1->ReplaceHeaderField("ReprocSpec",$PartLink,"ReprocSpec"); # so we can tell which spec produced exports
	$WFR1->AddHeaderField("ReprocSpec","DieBin");
	$WFR1->ReplaceHeaderField("DieBin",$DieBin,""); # DieBin obtained above
	if(GetMESLotID())
	{
		$WFR1->AddHeaderField("DieBin","MESLotID");
		$WFR1->ReplaceHeaderField("MESLotID",$MESLotID,"");
	}	
	print PARTSUMMARY "BoxBinning: $BoxBinning\n";
	print PARTSUMMARY "EllipseBinning: $EllipseBinning\n";

	print PARTSUMMARY "END_MODES\n";

	print PARTSUMMARY CheckLimits::ReportLimitsTable();
	print PARTSUMMARY BinnerVf::ReportBinsTable();
	if($BoxBinning && $EllipseBinning)
	{
		print PARTSUMMARY EllipseBinner::ReportEllipseBinsTable();
	}
	elsif($BoxBinning && !$EllipseBinning)
	{
		print PARTSUMMARY BoxBinner::ReportBoxBinsTable();
	}
	print PARTSUMMARY ProductStructure::ReportProductStructureTable(); # only the first 25 lines shown
	close PARTSUMMARY;



	 if(-e $PartsSummaryPath)
           {
               my $summaryCRC = ProgramInit::fileCRC($PartsSummaryPath);
               my $pathWithCRC = $PartsSummaryPath;
               $pathWithCRC =~ s/_temp.txt/_$summaryCRC.txt/;
               File::Copy::copy($PartsSummaryPath, $pathWithCRC);
               print "Generated PartsSummary file: $pathWithCRC\n";
               print LOG "Generated PartsSummary file: $pathWithCRC\n";
               # commented out for now, Siew's programs break with this extra field
               #$WFR1->AddHeaderField("DieBin","PartsSummary_CRC"); 
               #$WFR1->ReplaceHeaderField("PartsSummary_CRC",$summaryCRC,"PartsSummary_CRC");
               unlink $PartsSummaryPath; # get rid of the temp copy
            }

	# This Replaces PBVfFilter code.  Last part must be done after we get $Vf_x_uA_name initialized in ProcessWFR()
	#  ProductFamily ( tablename to load obtained from TesterParts2 Calibrated field for the current partnumber, collapses all eligible PNs into one key)
	#  Load %VfTable for this ProductFamily
	%VfTable = (); # reinitialize for another round of Vf table building
	# setup path for *_VfTable.txt
	if($ProductFamily eq 'NONE')
	{
		print "Unknown ProductFamily $ProductFamily. Skipping this tile!\n";
		return 1;
	}
	my $VfTablePath = $PartsDir."$ProductFamily\_VfTable.txt";
	open(VFTABLE, "<$VfTablePath") or die "Can't open $VfTablePath for reading!\n";
	my $headerline = <VFTABLE>;
	my @VfTableRecs = <VFTABLE>;
	chomp @VfTableRecs;
	close VFTABLE;
	
	foreach my $rec (@VfTableRecs)
	{
		my($prodfamily, $partprefix, $okdiebins, $temptc, $rxtype, $testname, $iforce, $vftestLL, $vftestUL) = split("\t", $rec);
		# FIXME: position dependent table
		# FIXME: cross match $L0Part with $PartPrefix(es) to prevent wrong table from being loaded
		my $onediebin=();
		if($okdiebins =~ /\:/g)
		{
			# more than 1 entry separated by | symbol
			my @diebinslist = split(':',$okdiebins);
			$onediebin = $diebinslist[0];
		}
		else
		{
			$onediebin = $okdiebins;
		}
		my $diebingroup = GetDieBinGroup($onediebin);  # just match up the first diebin in the list, assuming there is no overlap
		my $key = "$diebingroup\_$temptc\_$rxtype\_$testname";
		@{$VfTable{$key}} = ($vftestLL, $vftestUL);
	}
	# Extract VfTestLL and VfTestUL for 4 possible Vf testnames:  Vf2, VfLow, Vf_21_uA, Vf_10_uA
	# TempTC ( temperature testcondition extracted from WFR Filename)
	# RxType (Reactor type first for whole tile in first draft, then by die when merging DLTX files)
	my $tileidTC = $WaferID;
    $tileidTC =~ s/-$Iforce$//;  # remove drive condition from the end position
    $tileidTC =~ s/-$VISpoststep$//gi; # next, chop off the timepoint from the WaferID if there
	if($tileidTC =~ /-Tj[0-9]{2,3}$/i)   # is there a -TjNNN in the last position?
	{
		my @tempparts= split("-Tj",$tileidTC);
		$TempTC= $tempparts[-1]; # take the last item in the list
		$TempTC .= 'C';  # so format is 85C or 105C
	}
	else
	{
		$TempTC = '25C';  # so format is 25C
	}
	
	$RxType = "G4";  # global variable FIXME: THIS IS ONLY TEMPORARILY GOOD FOR WAHOOMPU6.  Must start pulling RxType from the new DLTX files generated from GGI files
	# overwrite the default Vf limits loaded from the Limits file after the variable $Vf_x_uA is initialized.
	$DieBinGroup = (); # global variable
	$DieBinGroup = GetDieBinGroup($DieBin);  # for the current tile, obtained from the BlueDB above.
	return 1;
}

sub GetDieBinGroup($) # DieBin (B931, B1, etc.)
{
	#  DieBinGroup (dB1, dB2, dB3, dB4, dB5, dB261, dB262 assigned after converting actual DieBin which can be 5nm, 2.5nm, H/R grade) 
	my $diebin = shift;
	my $dbgroup = "";
	
	if($diebin =~ /^(B1|P1|S1|A1|G1|A211|A212|G211|G212|L1|R1)$/i)
	{
		$dbgroup = "dB1";
	}
	elsif($diebin =~ /^(B2|B221|B222|B920|B921|B922|P2|P221|P222|P920|P921|P922|S2|S221|S222|S920|S921|S922|B320|B321|B322|B820|B821|B822|P320|P321|P322|P820|P821|P822|S320|S321|S322|S820|S821|S822|A2|A221|A222|A920|A921|A922|A320|A321|A322|A820|A821|A822|G2|G221|G222|G920|G921|G922|G321|G322|G320|G821|G822|G820|L2|L221|L222|L920|L921|L922|L321|L322|L320|L821|L822|L820|R2|R221|R222|R920|R921|R922|R321|R322|R320|R821|R822|R820|R422|O421|O422|F321)$/i)
	{
		$dbgroup = "dB2";
	}
	elsif($diebin =~ /^(B3|B231|B232|B930|B931|B932|P3|P231|P232|P930|P931|P932|S3|S231|S232|S930|S931|S932|B330|B331|B332|B830|B831|B832|P330|P331|P332|P830|P831|P832|S330|S331|S332|S830|S831|S832|A3|A231|A232|A930|A931|A932|A330|A331|A332|A830|A831|A832|S231|S232|S931|S932|G3|G231|G232|G234|G930|G931|G932|G331|G332|G330|G831|G832|G830|L3|L231|L232|L930|L931|L932|L331|L332|L330|L831|L832|L830|R3|R231|R232|R930|R931|R932|R331|R332|R330|R831|R832|R830|R431|R432|R433|R434|O431|O432|N331|N332|N831|N832|F331)$/i)
	{
		$dbgroup = "dB3";
	}
	elsif($diebin =~ /^(B4|B241|B242|B940|B941|B942|P4|P241|P242|P940|P941|P942|S4|S241|S242|S940|S941|S942|B340|B341|B342|B840|B841|B842|P340|P341|P342|P840|P841|P842|S340|S341|S342|S840|S841|S842|A4|A241|A242|A940|A941|A942|A340|A341|A342|A840|A841|A842|S241|S242|S941|S942|S243|S943|S244|S944|G4|G241|G242|G243|G244|G940|G941|G942|G943|G944|G341|G342|G343|G344|G340|G841|G842|G843|G844|G840|L4|L241|L242|L243|L244|L940|L941|L942|L943|L944|L341|L342|L343|L344|L340|L841|L842|L843|L844|L840|R4|R241|R242|R243|R244|R940|R941|R942|R943|R944|R341|R342|R343|R344|R340|R841|R842|R843|R844|R840|R441|R442|R443|R444|N341|N841|N342|N842)$/i)
	{
		$dbgroup = "dB4";
	}
	elsif($diebin =~ /^(B5|B251|B252|B950|B951|B952|P5|P251|P252|P950|P951|P952|S5|S251|S252|S950|S951|S952|B350|B351|B352|B850|B851|B852|P350|P351|P352|P850|P851|P852|S350|S351|S352|S850|S851|S852|A5|A251|A252|A950|A951|A952|A350|A351|A352|A850|A851|A852|S251|S252|S951|S952|S253|S254|S953|S954|G5|G251|G252|G253|G254|G950|G951|G952|G953|G954|G351|G352|G350|G353|G354|G851|G852|G850|G853|G854|L5|L251|L252|L253|L254|L950|L951|L952|L953|L954|L351|L352|L350|L353|L354|L851|L852|L850|L853|L854|R5|R251|R252|R253|R254|R950|R951|R952|R953|R954|R351|R352|R350|R353|R354|R851|R852|R850|R853|R854|R451|R452|R453|R454|N351|N352|N851|N852)$/i)
	{
		$dbgroup = "dB5";
	}
	elsif($diebin =~ /^(B6|B261|P6|P261|S6|S261|B361|B861|P361|P861|S361|S861|A6|A261|A361|A861|G261|G361|G861|R6|R261)$/i)
	{
		$dbgroup = "dB261";
	}
	elsif($diebin =~ /^(B262|P262|S262|B362|B862|P362|P862|S362|S862|A262|A362|A862|G262|G362|G862|R262)$/i)
	{
		$dbgroup = "dB262";
	}
	elsif($diebin =~ /^(B54|P54|S54|A54|G54)$/i)
	{
		$dbgroup = "dB54";
	}
	elsif($diebin =~ /^(B55|P55|S55|A55|G55)$/i)
	{
		$dbgroup = "dB55";
	}
	elsif($diebin =~ /^(B56|P56|S56|A56|G56)$/i)
	{
		$dbgroup = "dB56";
	}
	elsif($diebin =~ /^(B57|P57|S57|A57|G57)$/i)
	{
		$dbgroup = "dB57";
	}
	elsif($diebin =~ /^(B58|P58|S58|A58|G58)$/i)
	{
		$dbgroup = "dB58";
	}
	else
	{
		$dbgroup = "NA";
	}
	return $dbgroup;
	return 1;
}

sub PrintPartSummary()
{
	# open filename based on TesterType+RawPath+Date in $PartsDir\$Summary
	
	# print TesterType
	# print program version string
	# print command-line options in use by this program
	# print TesterParts2 path and info for transformed TesterType used
	# print PartLinks.txt path used
	# print PartLinks record: PartLink name
	# print Limits path and file contents
	# print Binner path and file contents
	# print Box/Ellipse/Lp1BoxBins path and file contents
	# print ProdStructure path and file contents
	
	
}

#------------------------------- MAIN PROCESSING ROUTINE -------------------------
sub ProcessWFR # ()
{
	# Only filenames matching WFR*.blu will be processed
	
	# Process the Raw file before accessing fields within
	$WFR1 = new RawChopper();
	if(-z $FullWFRpath)  # is it a null file (0-length?)
	{
		print "$FullWFRpath is an empty file\n";
		return 0;
	}
	$numdierecs = $WFR1->RawSliceAndDice($FullWFRpath);  # in RawChopper.pm
	if($numdierecs < 10)
	{
		print "$FullWFRpath has less than 10 die records!\n";
		Win32::File::SetAttributes($FullWFRpath, $attrib | HIDDEN);
		print LOG "$FullWFRpath has less than 10 die records! HIDEing ...\n";
		print LOGNP "$FullWFRpath has less than 10 die records! HIDEing ...\n";
		return 0;
	}

	ResetCounters();
	
	# set product-type variables, and initialize limit set for this product
	SetProductType() || return 0;

	# Add any new die fields that we will using and/or writing out to reports
	$WFR1->AddDieField('%Area',"aNum");
	$WFR1->AddDieField("aNum","aRow");
	$WFR1->AddDieField("aRow","aCol");
	$WFR1->AddDieField("aCol","dNum");
	$WFR1->AddDieField("dNum","sdNum");
	$WFR1->AddDieField("Col","aColor");
	$WFR1->AddDieField("aColor","aIntensity");
	$WFR1->AddDieField("PassColor","BinNum");  # will be used for Bin Number that will appear in SAF or DCR exports
	$WFR1->AddDieField("BinNum","PartID");
	$WFR1->AddDieField("PartID","PnPBin");
	$WFR1->AddDieField("AreaName","BinOption");  # make all rebel consistent with a BinOption field
	
	$VISready = 0; # reset the flag, only set again if we are in right mode & right timepoint
	if($VISmerge eq "YES" && $WaferID =~ /\-$VISpoststep\-/i && $VISpoststep ne "NONE" && $MergeVISproduct eq "Y")
	{
		$WFR1->AddDieField("PnPBin","VISflag");
		$WFR1->AddDieField("VISflag","VIScode_$VISprestep1");
		if($VISprestep2 ne "NONE")
		{
			$WFR1->AddDieField("VIScode_$VISprestep1","VIScode_$VISprestep2");
		}
		if($VISprestep3 ne "NONE")
		{
			$WFR1->AddDieField("VIScode_$VISprestep2","VIScode_$VISprestep3");
		}
		#if($VISprestep4 ne "NONE")
		#{
		#	$WFR1->AddDieField("VIScode_$VISprestep3","VIScode_$VISprestep4");
		#}
		$VISready = 1;
	}
	elsif($VISmerge eq "YES" && $WaferID !~ /\-T[0-9]{3}?\-/ && $VISpoststep eq "NONE" && $MergeVISproduct eq "Y")
	{
		$WFR1->AddDieField("PnPBin","VISflag");
		$WFR1->AddDieField("VISflag","VIScode_$VISprestep1");
		if($VISprestep2 ne "NONE")
		{
			$WFR1->AddDieField("VIScode_$VISprestep1","VIScode_$VISprestep2");
		}
		if($VISprestep3 ne "NONE")
		{
			$WFR1->AddDieField("VIScode_$VISprestep2","VIScode_$VISprestep3");
		}
		#if($VISprestep4 ne "NONE")
		#{
		#	$WFR1->AddDieField("VIScode_$VISprestep3","VIScode_$VISprestep4");
		#}
		$VISready = 1;
	}
	elsif($VISmerge eq "YES" && $MergeVISproduct eq "Y")
	{
		$IsProduct = "N";  # should cover the -T530 case or other unwanted VISpoststep
		$VISready = 0;     # this case will result in no maps generated, but data will be sent to Syntricity
	}

	if($Conversion_Efficiency eq 'YES' )
	{
		$WFR1->AddDieField("BinOption","PostSaberFWT_PHIe");
		$WFR1->AddDieField("PostSaberFWT_PHIe","CE");
		$WFR1->AddDieField("CE","PostSaber_Lpk");
		$WFR1->AddDieField("PostSaber_Lpk","Epoxy_Bottom");		
		#$WFR1->AddDieField("CE","Epoxy_Bottom");
		$WFR1->AddDieField("Epoxy_Bottom","Epoxy_Right");
		$WFR1->AddDieField("Epoxy_Right","Epoxy_Top");
		$WFR1->AddDieField("Epoxy_Top","Epoxy_Left");
		$WFR1->AddDieField("Epoxy_Left","Epoxy_Average");
		# $WFR1->AddDieField("Epoxy_Average","WingHeight_Bottom");
		# $WFR1->AddDieField("WingHeight_Bottom","WingHeight_Right");
		# $WFR1->AddDieField("WingHeight_Right","WingHeight_Top");
		# $WFR1->AddDieField("WingHeight_Top","WingHeight_Left");
		# $WFR1->AddDieField("WingHeight_Left","WingHeight_Average");
	}
	
	# string that describes the first point & type of spec failure for Maverick
	if($L1Part =~ /^(DCLFFLPANC19|DCLFFLPANC12|DCLFFLPANC08|DCLFFLPANC16|DCLFFLPANC15|DCLFFLPANC01|DCLFFLPANC05|DCLFFLPANC04|DCLFFLPANC07|DCLFFLPANC13|DCLFFLPANC14|DCLFFLPANC21|DCLFFLPANC22|DCLFFLPANC23|DCLFFLPANC18|DCLFFLPANC26|DCLFFLPANC17|DCLFFLPANC34|DCLFFLPANC48|DCLFFLPANC46|DCLFFLPANC45|DCLFFLPANC47|DCLFFLPANC44|DCLFFLPANC43|DCLFFLPANC41|DCLFFLPANC25|DCLFFLPANC42|DCLFFLPANC35|DCLFFLPANC38|DCLFFLPANC36|DCLFFLPANC40|DCLFFLPANC24|DCLFFLPANC39|DCLFFLPANC37|DCLFFLPANC52|DCLFFLPANC50|F6NL9XL-2|DCLFFLPANC02|DCLFFLPANC03|DCLFFLPANC09|DCLFFLPANC10|DCLFFLPANC11|DCLFFLPANC49|DCLFFLPANC33|DCLFFLPANC20|DCLFFLPANC59|DCLFFLPANC63|DCLFFLPANC64|DCLFFLPANC65|DCLFFLPANC66|DCLFFLPANC67|DCLFFLPANC68|DCLFFLPANC69|DCLFFLPANC70|DCLFFLPANC71|DCLFFLPANC72|DCLFFLPANC73|DCLFFLPANC74|DCLFFLPANC75|DCLFFLPANC76|DCLFFL576536)/i) #Rebel PCA parts
	{	
		$WFR1->AddDieField("Vf_10_uA","OutlierReject"); # string that describes the 
	}

	# unpack raw die data into array of arrays
	$WFR1->LoadDieFieldsArray();

	$BinColorName = BinnerVf::GetBinHeaderField("ColorBinParmName");
	$BinIntensityName = BinnerVf::GetBinHeaderField("LightBinParmName");
	$numArrayLeds = ProductStructure::GetNumberArrays();

	# Set up Vf_10_uA/Vf_20_uA  substitution variables for both Rebel and Wahoo usage
	if($WFR1->DieFieldExists("Vf_20_uA"))
	{
		$Vf_x_uA_name = "Vf_20_uA";  # Wahoo case
		$Vf_x_uA_value = ();
	}
	elsif($WFR1->DieFieldExists("Vf_21_uA"))
	{
		$Vf_x_uA_name = "Vf_21_uA";  # Wahoo case
		$Vf_x_uA_value = ();
	}
	else
	{
		$Vf_x_uA_name = "Vf_10_uA";  # Rebel 350 case
	}

	#*****************************************************************
	#**** Added to check duplicate die records in the file 22/08/2007 LCF****

	if($numdierecs > $numArrayLeds && $PartialMaps eq "notOK")
	{
		print "$FullWFRpath has MORE than $numArrayLeds die records ($numdierecs)!\n";
		Win32::File::SetAttributes($FullWFRpath, $attrib | HIDDEN);
		print LOG "$FullWFRpath has MORE than $numArrayLeds records ($numdierecs)!\n";
		print LOGNP "$FullWFRpath has MORE than $numArrayLeds records ($numdierecs)!\n";
		return 0;
	}
	#******************************************************************
	#*****************************************************************

	for( $die=0; $die < $numdierecs; $die++)  # All die and array counting is ZERO-based
	{
		# DieRecord level processing done for initialization of Limits and Array structures
		CheckLimits::SetDiePassAll($die); # Preset the dieflags for this die to all pass, then clear as needed
		my $drow = $WFR1->GetDieField($die,"Row");
		my $dcol = $WFR1->GetDieField($die,"Col");
		my $dRC = "R".$drow."C".$dcol;
		ProductStructure::AppendToDieHashes($die,$dRC);
	}
	my $numCompleteArrays = ProductStructure::ValidateArrays();  # check for incomplete arrays (because of short WFR), check each array as used
	
	if ($numCompleteArrays < $numArrayLeds && $PartialMaps eq "notOK")
	{
		# We have an incomplete WFR file.  Warn and return prematurely.
		print "\n******* $FullWFRpath is INCOMPLETE! \n******* Number of valid arrays = $numCompleteArrays.\n******* Cannot reprocess at this time. \n";
		Win32::File::SetAttributes($FullWFRpath, $attrib | HIDDEN);
		print LOG "$FullWFRpath is INCOMPLETE! Number of valid arrays = $numCompleteArrays! HIDEing ...\n";
		print LOGNP "$FullWFRpath is INCOMPLETE! Number of valid arrays = $numCompleteArrays! HIDEing ...\n";
		return 0;
	}
	# Merge in the Saber Visual Data if applicable
	%VIS_score = ();  # reset for each tile.
	
	if(!MergeVISstep($VISprestep1))
	{
		return 0; # some kind of error has occurred
	}

	if($VISprestep2 ne "NONE")
	{
		if( !MergeVISstep($VISprestep2))
		{
			return 0; # some kind of error has occurred
		}
	}
	if($VISprestep3 ne "NONE")
	{
		if( !MergeVISstep($VISprestep3))
		{
			return 0; # some kind of error has occurred
		}
	}
	#removeT520
	#if($VISprestep4 ne "NONE")
	#{
	#	if( !MergeVISstep($VISprestep4))
	#	{
	#		return 0; # some kind of error has occurred
	#	}
	#}
	
	# After all VIS merging has been done, disposition and set VISflag to wanted reject classifications
	#my %VISstep_score = (
	#	"T390" => 8,
	#	"T490" => 4,
	#	"T590" => 2,
	#	"T520" => 1 );

	#Reject criteria for Lux F.   Could be different for other product families in number of VIS steps and weighted VISflag assignments.
	#Saber	 OSC	Burn_In	 OVM	Weighted  Summary BinStat=1	BinStat<1
	#T390=8	T490=4	T590=2	T520=1	VIScore	VISflag	  RejName	RejName
	#	0		0	0		0		0		0	FAIL_VISrej	FAIL_Test_VISrej
	#	0		0	0		1		1		0	FAIL_VISrej	FAIL_Test_VISrej
	#	0		0	2		0		2		0	FAIL_VISrej	FAIL_Test_VISrej
	#	0		0	2		1		3		0	FAIL_VISrej	FAIL_Test_VISrej
	#	0		4	0		0		4		0	FAIL_VISrej	FAIL_Test_VISrej
	#	0		4	0		1		5		0	FAIL_VISrej	FAIL_Test_VISrej
	#	0		4	2		0		6		0	FAIL_VISrej	FAIL_Test_VISrej
	#	0		4	2		1		7		0	FAIL_VISrej	FAIL_Test_VISrej
	#	8		0	0		0		8		0	FAIL_VISrej	FAIL_Test_VISrej
	#	8		0	0		1		9		0	FAIL_VISrej	FAIL_Test_VISrej
	#	8		0	2		0		10		0	FAIL_VISrej	FAIL_Test_VISrej
	#	8		0	2		1		11		0	FAIL_VISrej	FAIL_Test_VISrej
	#	8		4	0		0		12		2	FAIL_Burn_In	FAIL_Test_VISrej
	#	8		4	0		1		13		2	FAIL_Burn_In	FAIL_Test_VISrej
	#	8		4	2		0		14		3	FAIL_OTHERS	FAIL_Test_VISrej
	#	8		4	2		1		15		1	<Pass Part>	FAIL_<testname>
	
	# Disposition VISflag for each unit based on the combination of all VISstep code presence or absence.  Scores were accumulated at the time of merging each step in MergeVISstep()
	#for( $arr=0; $arr < $numArrayLeds; $arr++)
	#{
	#	my ($aRow, $aCol) = ProductStructure::GetArrayRC($arr);
	#	@dieset = ProductStructure::GetDieSet4Array($arr);
	#	my $vis_score = $VIS_score{"$aRow\_$aCol"};   # the codes are mapped into aRow, aCol but only for this step
	#
	#	if($vis_score >= 0 && $vis_score <= 11) 
	#	{ 
	#		$WFR1->ReplaceDieFieldSet(@dieset,"VISflag",0);  # FAIL_VISrej or FAIL_Test_VISrej
	#	}
	#	elsif($vis_score == 15)
	#	{
	#		$WFR1->ReplaceDieFieldSet(@dieset,"VISflag",1);  # Passed all VIS checks
	#	}
	#	elsif($vis_score ==12 || $vis_score == 13)
	#	{
	#		$WFR1->ReplaceDieFieldSet(@dieset,"VISflag",2);  # FAIL_Burn_In
	#	}
	#	elsif($vis_score == 14)
	#	{
	#		$WFR1->ReplaceDieFieldSet(@dieset,"VISflag",3);  # FAIL_OTHERS
	#	}
	#}

	if($EPprestep ne "NONE" && $Conversion_Efficiency eq 'YES')
	{
		if(!MergeEPstep($EPprestep))
		{
			return 0; # some kind of error has occurred
		}
	}

	if($FWTpostest ne "NONE" && $Conversion_Efficiency eq 'YES')
	{
		if(!MergeFWTstep($FWTpostest) )
		{
			return 0; # some kind of error has occurred
		}
	}
	my ($TestName, $key, @VfTestLimits, $VfTestLL, $VfTestUL );
	$TestName = "Vf2";  #
	$key = "$DieBinGroup\_$TempTC\_$RxType\_$TestName";
	if(exists $VfTable{$key})
	{
		@VfTestLimits = @{$VfTable{$key}};  # %VfTable handles one ProductFamily only so no key for that
		$VfTestLL = $VfTestLimits[0];
		$VfTestUL = $VfTestLimits[1];
		if(defined $VfTestLL && $VfTestLL ne "NA")  # if TestName isn't in the table then the limits will be undefined so we can forget it
		{
			ReplaceLowerProdLimit("$TestName", $VfTestLL);
		}
		if(defined $VfTestUL && $VfTestUL ne "NA")
		{
			ReplaceUpperProdLimit("$TestName", $VfTestUL);
		}
	}
	$TestName = "VfLow";  
	$key = "$DieBinGroup\_$TempTC\_$RxType\_$TestName";
	if(exists $VfTable{$key})
	{
		@VfTestLimits = @{$VfTable{$key}};  # %VfTable handles one ProductFamily only so no key for that
		$VfTestLL = $VfTestLimits[0];
		$VfTestUL = $VfTestLimits[1];
		if(defined $VfTestLL && $VfTestLL ne "NA")  # if TestName isn't in the table then the limits will be undefined so we can forget it
		{
			ReplaceLowerProdLimit("$TestName", $VfTestLL);
		}
		if(defined $VfTestUL && $VfTestUL ne "NA")
		{
			ReplaceUpperProdLimit("$TestName", $VfTestUL);
		}
	}
	$TestName = "Vf_10_uA"; 
	$key = "$DieBinGroup\_$TempTC\_$RxType\_$TestName";
	if(exists $VfTable{$key})
	{
		@VfTestLimits = @{$VfTable{$key}};  # %VfTable handles one ProductFamily only so no key for that
		$VfTestLL = $VfTestLimits[0];
		$VfTestUL = $VfTestLimits[1];
		if(defined $VfTestLL && $VfTestLL ne "NA")  # if TestName isn't in the table then the limits will be undefined so we can forget it
		{
			ReplaceLowerProdLimit("$Vf_x_uA_name", $VfTestLL);
		}
		if(defined $VfTestUL && $VfTestUL ne "NA")
		{
			ReplaceUpperProdLimit("$Vf_x_uA_name", $VfTestUL);
		}
	}
	$TestName = "Vf_21_uA";  # CAUTION $Vf_x_uA_name could be Vf_20_uA or Vf_21_uA in the Limits file and WFR
	 # but we use just Vf_21_uA in the VfTable, so we have to use the right testname for overwriting the limits table.
	$key = "$DieBinGroup\_$TempTC\_$RxType\_$TestName";
	if(exists $VfTable{$key})
	{
		@VfTestLimits = @{$VfTable{$key}};  # %VfTable handles one ProductFamily only so no key for that
		$VfTestLL = $VfTestLimits[0];
		$VfTestUL = $VfTestLimits[1];
		if(defined $VfTestLL && $VfTestLL ne "NA")  # if TestName isn't in the table then the limits will be undefined so we can forget it
		{
			ReplaceLowerProdLimit("$Vf_x_uA_name", $VfTestLL);
		}
		if(defined $VfTestUL && $VfTestUL ne "NA")
		{
			ReplaceUpperProdLimit("$Vf_x_uA_name", $VfTestUL);
		}
	}
	
	#if ($L1Part =~ /^(DCLFFLPANC12|DCLFFLPANC08|DCLFFLPANC16|DCLFFLPANC15|DCLFFLPANC04|DCLFFLPANC07|DCLFFLPANC13|DCLFFLPANC14|DCLFFL576501)$/i)
	if($WFR1->DieFieldExists("VfPost01"))
	{
		$TestName = "VfPost01";  
		$key = "$DieBinGroup\_$TempTC\_$RxType\_$TestName";
		if(exists $VfTable{$key})
		{
			@VfTestLimits = @{$VfTable{$key}};  # %VfTable handles one ProductFamily only so no key for that
			$VfTestLL = $VfTestLimits[0];
			$VfTestUL = $VfTestLimits[1];
			if(defined $VfTestLL && $VfTestLL ne "NA")  # if TestName isn't in the table then the limits will be undefined so we can forget it
			{
				ReplaceLowerProdLimit("$TestName", $VfTestLL);
			}
			if(defined $VfTestUL && $VfTestUL ne "NA")
			{
				ReplaceUpperProdLimit("$TestName", $VfTestUL);
			}
		}
	}
	#  proceed to regular Limit checking and binning

	

	# Examine each arrayLed for limits, etc., which will not be in die record order, but uses @dieset lists instead
	for( $arr=0; $arr < $numArrayLeds; $arr++)
	{
		#print "$arr\n";
		ProductStructure::IsArrayComplete($arr) || next; # skip this array/singleLED and go to the next one
		$ActualTested ++;
		@dieset = ProductStructure::GetDieSet4Array($arr);
		if($LMWbinning eq 'YES')
		{
			my @vfset = $WFR1->GetDieFieldSet(@dieset,"Vf2");
			my $vf = CheckLimits::CombineValSet(@vfset,"Vf2");
			my @fluxset = $WFR1->GetDieFieldSet(@dieset,"PHIv");
			my $lumens = CheckLimits::CombineValSet(@fluxset,"PHIv");
			my $efficacy = 0;
			if(($vf*$Iforce) != 0)
			{
				$efficacy = $lumens/($vf*$Iforce/1000); # in Lumens/eWatt
			}
			$WFR1->ReplaceDieFieldSet(@dieset,"Efficacy",$efficacy);
		}
		# Limit checks, product binning will now be done for each array
		foreach $fieldname ($WFR1->GetDieFieldNames())
		{
			my @vals = $WFR1->GetDieFieldSet(@dieset,$fieldname);
			my $limitchkflag = CheckLimits::LimitCheckSet(\@dieset, \@vals, $fieldname);
		}
  		my $VISflag = 1;
		if($VISready)
		{   # AND in the value of the VISflag when it exists
			my @vflg = $WFR1->GetDieFieldSet(@dieset,"VISflag");
			$VISflag = $vflg[0];
		}
		my $CE;
		my @PHIv = $WFR1->GetDieFieldSet(@dieset,"PHIv");
		my $PHIv = $PHIv[0];
		my @L1PHIe = $WFR1->GetDieFieldSet(@dieset,"PHIe");
		my $L1PHIe = $L1PHIe[0];

		if ($Conversion_Efficiency eq 'YES')
		{
			#Calculate for CE
			my @PHIe = $WFR1->GetDieFieldSet(@dieset,"PostSaberFWT_PHIe");
			my $PHIe = $PHIe[0];
			if ($PHIe =~ /\S/ && $PHIe > 1 )   # there is negative(invalid value for PHIe)
			{
				if($RadioPhoto eq 'Radio')
				{
					$CE = $L1PHIe / $PHIe;  # radiometric version of CE, for pump parts
				}
				else
				{
					$CE = ($PHIv *1000) / $PHIe;
				}
				$WFR1->ReplaceDieFieldSet(@dieset,"CE",$CE);
			}
			elsif($PHIe !~ /\S/)
			{
				$WFR1->ReplaceDieFieldSet(@dieset,"CE","NA");
			}
		}

		if (CheckLimits::ShowDiePassAllSet(@dieset)) # passed all limit checks, but not sure about Product Bin rejects yet
		{
			# get and combine the bin variables for color and intensity
			my @intensityset = $WFR1->GetDieFieldSet(@dieset,$BinIntensityName);
			my $intensity = CheckLimits::CombineValSet(@intensityset,$BinIntensityName);
			my @lambdaset = ();
			my $lambda;
			my @vfset = $WFR1->GetDieFieldSet(@dieset,"Vf2");
			my $vf = CheckLimits::CombineValSet(@vfset,"Vf2");
			my @CLV;
			my $C;
			my $L;
			my $V;

			if($BoxBinning == 1 && $BinColorName eq "CCT")
			{
				#if ($L1Part =~ /^(DCLFFS576517)$/i) #remove
				#{
				#	my @uprimeset = $WFR1->GetDieFieldSet(@dieset,"u_prime");
				#	my @vprimeset = $WFR1->GetDieFieldSet(@dieset,"v_prime");
				#	my $uprime = CheckLimits::CombineValSet(@uprimeset,"u_prime");
				#	my $vprime = CheckLimits::CombineValSet(@vprimeset,"v_prime");
				#	
				#	
				#	my $newuprimeset = ($uprime-0.00075);
				#	$WFR1->ReplaceDieFieldSet(@dieset,"u_prime",$newuprimeset);
				#	@uprimeset= $newuprimeset;
				#	$uprime = CheckLimits::CombineValSet(@uprimeset,"u_prime"); 
				#	
				#	my $newvprimeset = ($vprime-0.00050);
				#	$WFR1->ReplaceDieFieldSet(@dieset,"v_prime",$newvprimeset);
				#	@vprimeset= $newvprimeset;
				#	$vprime = CheckLimits::CombineValSet(@vprimeset,"v_prime");
				#}
								
				my @uprimeset = $WFR1->GetDieFieldSet(@dieset,"u_prime");
				my @vprimeset = $WFR1->GetDieFieldSet(@dieset,"v_prime");
				my $uprime = CheckLimits::CombineValSet(@uprimeset,"u_prime");
				my $vprime = CheckLimits::CombineValSet(@vprimeset,"v_prime");
				my @xledset = $WFR1->GetDieFieldSet(@dieset,"Xled");   # in case we have to do elliptical binning
				my @yledset = $WFR1->GetDieFieldSet(@dieset,"Yled");
				my $xled = CheckLimits::CombineValSet(@xledset,"Xled");
				my $yled = CheckLimits::CombineValSet(@yledset,"Yled");
				@lambdaset = $WFR1->GetDieFieldSet(@dieset,$BinColorName);  # pick up CCT for purposes of WFR aColor
				$lambda = CheckLimits::CombineValSet(@lambdaset,$BinColorName); # and FineBinning
				if($EllipseBinning == 1)
				{
					$C = EllipseBinner::EllipseBin($xled,$yled);  # get the ellipse bin color code (2 characters)
				}
				else
				{
					$C = BoxBinner::BoxBin($uprime,$vprime);  # get the box bin color code (2 characters)
				}
				if($BinDefs eq 'MULTI')
				{
					@CLV = BinnerVf::BinSearchWhite($C,$intensity,$vf);
					$C = $CLV[0];
				}
				elsif($BinDefs eq 'SINGLE')
				{
					@CLV = BinnerVf::BinThis(-999,$intensity,$vf); # ignore returned colorcode for now if white
				}
				else
				{
					@CLV = BinnerVf::BinThis(-999,$intensity,$vf); # ignore returned colorcode for now if white
				}
				$L = $CLV[1];  # ignore the color bin code returned by standard binner, only use intensity code
				$V = $CLV[2];         # extract Vf bincode
				# Note: for actual product color binning we are using box-binning, but for fine-binning we are using CCT
				# and in the aColor field.  Requires the BinColorName in the Binner is set to CCT.
				# Will stay like this until I can implement a 2D FineBinning routine.
			}
			else
			{	
				@lambdaset = $WFR1->GetDieFieldSet(@dieset,$BinColorName);
				$lambda = CheckLimits::CombineValSet(@lambdaset,$BinColorName);
				if($BinDefs eq 'MULTI')
				{
					@CLV = BinnerVf::BinSearchColor($lambda,$intensity,$vf);
				}
				elsif($BinDefs eq 'SINGLE')
				{
					@CLV = BinnerVf::BinThis($lambda,$intensity,$vf);
				}
				else
				{
					@CLV = BinnerVf::BinThis($lambda,$intensity,$vf);
				}
				$C = $CLV[0];         # extract color bincode
				$L = $CLV[1];         # extract intensity bincode
				$V = $CLV[2];         # extract Vf bincode
			}

			# check for Product Bincode pass/fail
			$BinStatus[$arr] = BinnerVf::CheckBincode($C,$L,$V); # save new Binstatus per die for WFM/WFR reports
			my $clv = $C.$L.$V;                       # concatenate CLV bincode for Color+Flux+vf, for working with Bin tables
			my $lcv = $L.$C.$V;                       # concatenate LCV bincode for Flux+Color+vf, this is the way production wants to see it
			if($SingleWhiteBin eq "YES")
			{   # this mode was put in for MagLite, so we could reassign the boxbin codes to a single don't care color bin xx
				$lcv = $L."xx".$V;  #  for final bin assignment, but not any internal uses like looking up PnP bins
			}

			$WFR1->ReplaceDieFieldSet(@dieset,"BinStatus", $BinStatus[$arr]);  # each die gets same BinStatus as its array
			$WFR1->ReplaceDieFieldSet(@dieset,"aColor",$lambda);
			$WFR1->ReplaceDieFieldSet(@dieset,"aIntensity",$intensity);

			# Disposition each arrayled according to BinStatus or set BinStatus for VISrej
			if($BinStatus[$arr] == 1 && $VISflag == 1)
			{
				$ProductBinCounts{$lcv}++;          # Add to product bin counts ( only good in all respects )
				$PartID[$arr] = $lcv;               # Add Bincat to PartID array for good ones only
				$TotalGoodDie++;
				$WFR1->ReplaceDieFieldSet(@dieset,"PartID", $L0Part.$PartID[$arr]);
				my $pnpbin =  BinnerVf::GetPnPBin($clv);
				$WFR1->ReplaceDieFieldSet(@dieset,"PnPBin", $pnpbin);
				my $BinNumber = BinnerVf::GetBinNumber($clv);
				$WFR1->ReplaceDieFieldSet(@dieset,"BinNum", $BinNumber);  # for pass bins only
				BinnerVf::FineBin($lambda,$intensity);	# Add array result to color/intensity fine bins
				if ($Conversion_Efficiency eq 'YES')
				{
					if ($CE > 80 && $CE <300 )
					{
						$WFR1->ReplaceDieFieldSet(@dieset,"CE",$CE);
					}
					else
					{
						$WFR1->ReplaceDieFieldSet(@dieset,"CE","NA");
					}
				}
			}
			elsif($BinStatus[$arr] == -1 && $VISflag == 1)
			{
				$ColorRejCounts{$lcv}++;            # Increment different types of reject counters
				CheckLimits::SetDieFailTNameSet(@dieset,$BinColorName);   # and Set the DieFlags for this die to reflect reject type
				my $rej = CheckLimits::ShowDieFlagsSet(@dieset);
				$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "FAIL_$rej");  # will be replaced in MavSummaryRecord()
				$WFR1->ReplaceDieFieldSet(@dieset,"PnPBin", 0);
			}
			elsif($BinStatus[$arr] == -2 && $VISflag == 1)
			{
				$IvRejCounts{$lcv}++;
				CheckLimits::SetDieFailTNameSet(@dieset,$BinIntensityName);
				my $rej = ShowDieFlagsSet(@dieset);
				$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "FAIL_$rej"); # will be replaced in MavSummaryRecord()
				$WFR1->ReplaceDieFieldSet(@dieset,"PnPBin", 0);
			}
			elsif($BinStatus[$arr] == -3 && $VISflag == 1) # -3 means that failed both Iv and Color
			{
				$LightRejCounts{$lcv}++;
				CheckLimits::SetDieFailTNameSet(@dieset,$BinColorName);
				CheckLimits::SetDieFailTNameSet(@dieset,$BinIntensityName);
				my $rej = CheckLimits::ShowDieFlagsSet(@dieset);
				$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "FAIL_$rej"); # will be replaced in MavSummaryRecord()
				$WFR1->ReplaceDieFieldSet(@dieset,"PnPBin", 0);
			}
			elsif($BinStatus[$arr] == -5 && $VISflag == 1) # -5 means that No_Vf_Bin
			{
				$LightRejCounts{$lcv}++;
				CheckLimits::SetDieFailTNameSet(@dieset,$BinColorName);
				CheckLimits::SetDieFailTNameSet(@dieset,$BinIntensityName);
				my $rej = CheckLimits::ShowDieFlagsSet(@dieset);
				$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "FAIL_$rej"); # will be replaced in MavSummaryRecord()
				$WFR1->ReplaceDieFieldSet(@dieset,"PnPBin", 0);
			}
			elsif($VISflag == 0) # Failed Saber Visual Inspection but passed limits
			{
				my $rej = CheckLimits::ShowDieFlagsSet(@dieset);
				$VisRejCounts{"VIS_$rej"}++;
				$TotalVISrej++;
				$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "FAIL_VIS_$rej"); # will be replaced in MavSummaryRecord()
				$WFR1->ReplaceDieFieldSet(@dieset,"PnPBin", 0);
			}
			elsif($VISflag == 2) # Failed BurnIn
			{
				my $rej = CheckLimits::ShowDieFlagsSet(@dieset);
				$VisRejCounts{"VIS_$rej"}++;
				$TotalVISrej++;
				#$BinStatus[$arr] = 0;  
				$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "FAIL_Burn_In");
				$WFR1->ReplaceDieFieldSet(@dieset,"PnPBin", 0);
			}
			#elsif($VISflag == 3) #Failed OVM T520 as FAIL_OTHERS
			#{
			#	my $rej = CheckLimits::ShowDieFlagsSet(@dieset);
			#	$VisRejCounts{"VIS_$rej"}++;
			#	$TotalVISrej++;
			#	#$BinStatus[$arr] = 0;  
			#	$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "FAIL_OTHERS");
			#	$WFR1->ReplaceDieFieldSet(@dieset,"PnPBin", 0);
			#}
		}	# end if passed limit checks
		else # Failed limit checks
		{
			if($VISflag == 1)
			{
				my $rej = "FAIL_".CheckLimits::ShowDieFlagsSet(@dieset);
				$LimitRejCounts{$rej}++;            # Count Limit rejects
				$BinStatus[$arr] = 0;               # 0 for limit failures
				$WFR1->ReplaceDieFieldSet(@dieset,"PartID", $rej);  # will be replaced in MavSummaryRecord()
				$WFR1->ReplaceDieFieldSet(@dieset,"PnPBin", 0);
			}
			else  # Failed Saber Visual Inspection and a limit check
			{
				my $rej = CheckLimits::ShowDieFlagsSet(@dieset);
				$VisRejCounts{"VIS_$rej"}++;
				$TotalVISrej++;
				$BinStatus[$arr] = 0;               # 0 for limit failures
				$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "FAIL_VIS_$rej");  # will be replaced in MavSummaryRecord()
				$WFR1->ReplaceDieFieldSet(@dieset,"PnPBin", 0);
			}
		}

		# Update dieflag fields for each die record in array
		my $comboflags = CheckLimits::ShowDieFlagsSet(@dieset);
		my @splitflags = split("",$comboflags);
		$WFR1->ReplaceDieFieldSet(@dieset,"PassVRev",$splitflags[0]);
		$WFR1->ReplaceDieFieldSet(@dieset,"PassLight",$splitflags[1]);
		$WFR1->ReplaceDieFieldSet(@dieset,"PassVFwd",$splitflags[2]);
		$WFR1->ReplaceDieFieldSet(@dieset,"PassVfLow",$splitflags[3]);
		$WFR1->ReplaceDieFieldSet(@dieset,"PassColor",$splitflags[4]);
		# Do the same for the BinStatus field
		$WFR1->ReplaceDieFieldSet(@dieset,"BinStatus",$BinStatus[$arr]);

		# Also update aNum, aRow, aCol for each @dieset
		$WFR1->ReplaceDieFieldSet(@dieset,"aNum",$arr);
		my @thisArrayRC = ProductStructure::GetArrayRC($arr);
		$WFR1->ReplaceDieFieldSet(@dieset,"aRow",$thisArrayRC[0]);
		$WFR1->ReplaceDieFieldSet(@dieset,"aCol",$thisArrayRC[1]);
		# BinOption indicates whether we used STD binning configuration or some
		#   other special like LMW, ANS, IGZ.  Needed for L2 Binning.
		$WFR1->ReplaceDieFieldSet(@dieset,"BinOption", $BinOption);
		# for each dierec in @dieset, fetch & update the unique dNum and sdNum
		foreach my $dr (@dieset)
		{
			$WFR1->ReplaceDieField($dr,"dNum",$dr);
			$WFR1->ReplaceDieField($dr,"sdNum",GetSd4Die($dr));
		}				
	} # end of array processing loop
	
	#if($L1Part =~ /^(DCLFFLPANC08|DCLFFLPANC12|DCLFFLPANC15|DCLFFLPANC16|DCLFFLPANC18|DCLFFLPANC21|DCLFFLPANC22|DCLFFLPANC23|DCLFFLPANC24|DCLFFLPANC25|DCLFFLPANC33|DCLFFLPANC34|DCLFFLPANC35|DCLFFLPANC36|DCLFFLPANC37|DCLFFLPANC38|DCLFFLPANC39|DCLFFLPANC40|DCLFFLPANC41|DCLFFLPANC42|DCLFFLPANC49|DCLFFLPANC50|DCLFFLPANC20|DCLFFLPANC69|DCLFFLPANC70)/i)  #Rebel PCA parts
	if($L1Part =~ /^(DCLFFLPANC34|DCLFFLPANC35|DCLFFLPANC36|DCLFFLPANC37|DCLFFLPANC38|DCLFFLPANC39|DCLFFLPANC40|DCLFFLPANC42|DCLFFLPANC69)/i) #Rebel PCA parts
	{
		ApplyVf2Maverick();
	}
	
	if($L1Part =~ /^(DCLFFLPANC12|DCLFFLPANC08|DCLFFLPANC16|DCLFFLPANC15|DCLFFLPANC01|DCLFFLPANC05|DCLFFLPANC04|DCLFFLPANC07|DCLFFLPANC13|DCLFFLPANC14|DCLFFLPANC21|DCLFFLPANC22|DCLFFLPANC23|DCLFFLPANC18|DCLFFLPANC26|DCLFFLPANC17|DCLFFLPANC34|DCLFFLPANC48|DCLFFLPANC46|DCLFFLPANC45|DCLFFLPANC47|DCLFFLPANC44|DCLFFLPANC43|DCLFFLPANC41|DCLFFLPANC25|DCLFFLPANC42|DCLFFLPANC35|DCLFFLPANC38|DCLFFLPANC36|DCLFFLPANC40|DCLFFLPANC24|DCLFFLPANC39|DCLFFLPANC37|DCLFFLPANC50|DCLFFLPANC20|DCLFFLPANC59|DCLFFLPANC63|DCLFFLPANC66|DCLFFLPANC10|DCLFFLPANC11|DCLFFLPANC64|DCLFFLPANC65|DCLFFLPANC67|DCLFFLPANC68|DCLFFLPANC69|DCLFFLPANC70|DCLFFLPANC71|DCLFFLPANC72|DCLFFLPANC73|DCLFFLPANC74|DCLFFLPANC75|DCLFFLPANC76)/i)  #Rebel PCA parts
	{
		ApplyPHIvMaverick();
	}
	
	if ($L1Part =~ /^(DCLFFLPANC|DCLFFL576536)$/i) #Rebel PCA parts
	{
		ApplyVfxMaverick();
	}
		
	return DoReports();
}  	# end of sub ProcessWFR()


sub ApplyVf2Maverick()
{
	#Vf2Outlier
			
	my @Vf2Good = ();
	
	$Vf2OutlierCounts = 0;
	
	for( $arr=0; $arr < $numArrayLeds; $arr++)
	{
		ProductStructure::IsArrayComplete($arr) || next;
		@dieset = ProductStructure::GetDieSet4Array($arr);
	
		my $VISflag = 1;
		if($VISready)
		{  
			my @vflg = $WFR1->GetDieFieldSet(@dieset,"VISflag");
			$VISflag = $vflg[0];
		}
		if($BinStatus[$arr] == 1 && $VISflag == 1) # only collect values for standard good parts
		{
			my @Vf2set = $WFR1->GetDieFieldSet(@dieset,"Vf2");
			my $Vf2 = CheckLimits::CombineValSet(@Vf2set,"Vf2");
			push(@Vf2Good, $Vf2);
		}
	}				
				
	#Calculate Vf2 mean, stdev, USL, LSL
		
	my %Stats_Vf2 =  StatisticsLite::statshash(@Vf2Good);
	my $Mode_Vf2 = $Stats_Vf2{"mode"};
	my $Stdev_Vf2 = $Stats_Vf2{"stddev"};
	$Vf2_Mode = $Mode_Vf2;
	$Vf2_Stdev = $Stdev_Vf2;
	$Vf2_USL = $Mode_Vf2 + 3 * $Stdev_Vf2;	#3sigma
	$Vf2_LSL = $Mode_Vf2 - 3 * $Stdev_Vf2;
		
	#print "Vf2_Mean: $Vf2_Mean\n";
	#print "Vf2_Stdev: $Vf2_Stdev\n";
	#print "Vf2_USL: $Vf2_USL\n";
	#print "Vf2_LSL: $Vf2_LSL\n";
			
	for( $arr=0; $arr < $numArrayLeds; $arr++)
	{
		ProductStructure::IsArrayComplete($arr) || next;
		@dieset = ProductStructure::GetDieSet4Array($arr);
	
		my $VISflag = 1;
		if($VISready)
		{  
			my @vflg = $WFR1->GetDieFieldSet(@dieset,"VISflag");
			$VISflag = $vflg[0];
		}
		if($BinStatus[$arr] == 1 && $VISflag == 1) # only collect values for standard good parts
		{
			my @Vf2set = $WFR1->GetDieFieldSet(@dieset,"Vf2");
			my $Vf2 = CheckLimits::CombineValSet(@Vf2set,"Vf2");
			#if( $Vf2 < $Vf2_LSL)
			#{
			#	
			#	#my $ort= "ORT"; 
			#	my $LSL = sprintf("%0.5f", $Vf2_LSL);
			#	$Vf2_reject = "$Vf2\_LSL\_$LSL";
			#	$TotalGoodDie--;
			#	#$BinStatus[$arr] = 0;        
			#	$RejParetoCounts{"numLow_Vf2_Outlier"}++;
			#	
			#	$Vf2OutlierCounts ++;
			#	$WFR1->ReplaceDieFieldSet(@dieset,"BinNum", 9997); 
			#	$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "FAIL_Low_Vf2_Outlier");
			#	#$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "$L0Part$ort");
			#	$WFR1->ReplaceDieFieldSet(@dieset,"PnPBin", 0);
			#	$WFR1->ReplaceDieFieldSet(@dieset,"BinStatus",0);
			#	$WFR1->ReplaceDieFieldSet(@dieset,"OutlierReject", $Vf2_reject );
			#	next;
			#}
                        if( $Vf2 > $Vf2_USL)
			{
				
				
				my $USL = sprintf("%0.5f", $Vf2_USL);
				$Vf2_reject = "$Vf2\_USL\_$USL";
				$TotalGoodDie--;
				#$BinStatus[$arr] = 0;        
				$RejParetoCounts{"numHigh_Vf2_Outlier"}++;
				
				$Vf2OutlierCounts ++;
				$WFR1->ReplaceDieFieldSet(@dieset,"BinNum", 9998); 
				$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "FAIL_High_Vf2_Outlier");
				$WFR1->ReplaceDieFieldSet(@dieset,"PnPBin", 0);
				$WFR1->ReplaceDieFieldSet(@dieset,"BinStatus",0);
				$WFR1->ReplaceDieFieldSet(@dieset,"OutlierReject", $Vf2_reject );
				next;
			}
		}
	}				
}

sub ApplyPHIvMaverick()
{
	#PHIv Outlier
			
	my @PHIvGood = ();
	
	$PHIvOutlierCounts = 0;
	
	for( $arr=0; $arr < $numArrayLeds; $arr++)
	{
		ProductStructure::IsArrayComplete($arr) || next;
		@dieset = ProductStructure::GetDieSet4Array($arr);
	
		my $VISflag = 1;
		if($VISready)
		{  
			my @vflg = $WFR1->GetDieFieldSet(@dieset,"VISflag");
			$VISflag = $vflg[0];
		}
		if($BinStatus[$arr] == 1 && $VISflag == 1) # only collect values for standard good parts
		{
			my @PHIvset = $WFR1->GetDieFieldSet(@dieset,"PHIv");
			my $PHIv = CheckLimits::CombineValSet(@PHIvset,"PHIv");
			push(@PHIvGood, $PHIv);
		}
	}				
				
	#Calculate PHIv mean, stdev, USL, LSL
		
	my %Stats_PHIv =  StatisticsLite::statshash(@PHIvGood);
	my $Mean_PHIv = $Stats_PHIv{"mean"};
	my $Stdev_PHIv = $Stats_PHIv{"stddev"};
	$PHIv_Mean = $Mean_PHIv;
	$PHIv_Stdev = $Stdev_PHIv;
	$PHIv_USL = $Mean_PHIv + 4 * $Stdev_PHIv;	#4sigma
	$PHIv_LSL = $Mean_PHIv - 4 * $Stdev_PHIv;
		
	#print "PHIv_Mean: $PHIv_Mean\n";
	#print "PHIv_Stdev: $PHIv_Stdev\n";
	#print "PHIv_USL: $PHIv_USL\n";
	#print "PHIv_LSL: $PHIv_LSL\n";
			
	for( $arr=0; $arr < $numArrayLeds; $arr++)
	{
		ProductStructure::IsArrayComplete($arr) || next;
		@dieset = ProductStructure::GetDieSet4Array($arr);
	
		my $VISflag = 1;
		if($VISready)
		{  
			my @vflg = $WFR1->GetDieFieldSet(@dieset,"VISflag");
			$VISflag = $vflg[0];
		}
		if($BinStatus[$arr] == 1 && $VISflag == 1) # only collect values for standard good parts
		{
			my @PHIvset = $WFR1->GetDieFieldSet(@dieset,"PHIv");
			my $PHIv = CheckLimits::CombineValSet(@PHIvset,"PHIv");
			if( $PHIv < $PHIv_LSL)
			{
				
				#my $ort= "ORT"; 
				my $LSL = sprintf("%0.5f", $PHIv_LSL);
				$PHIv_reject = "$PHIv\_LSL\_$LSL";
				$TotalGoodDie--;
				#$BinStatus[$arr] = 0;        
				$RejParetoCounts{"numLow_PHIv_Outlier"}++;
				
				$PHIvOutlierCounts ++;
				$WFR1->ReplaceDieFieldSet(@dieset,"BinNum", 9976); 
				$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "FAIL_Low_PHIv_Outlier");
				#$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "$L0Part$ort");
				$WFR1->ReplaceDieFieldSet(@dieset,"PnPBin", 0);
				$WFR1->ReplaceDieFieldSet(@dieset,"BinStatus",0);
				$WFR1->ReplaceDieFieldSet(@dieset,"OutlierReject", $PHIv_reject );
				next;
			}
		}
	}				
}

# Implemented by Thaufiq on 30/05/2024
# Implement Vf10uA Outlier Screening to F CW Marlin (Rhui Ting)
sub ApplyVfxMaverick()
{
	print "1710 checking 1" ;
	#Vf_x_uA Outlier
			
	my @Vf_x_uA_Good = ();
	
	$Vf_x_uA_OutlierCounts = 0;
	
	for( $arr=0; $arr < $numArrayLeds; $arr++)
	{
		ProductStructure::IsArrayComplete($arr) || next;
		@dieset = ProductStructure::GetDieSet4Array($arr);
	
		my $VISflag = 1;
		if($VISready)
		{  
			my @vflg = $WFR1->GetDieFieldSet(@dieset,"VISflag");
			$VISflag = $vflg[0];
		}
		if($BinStatus[$arr] == 1 && $VISflag == 1) # only collect values for standard good parts
		{
			my @Vf_x_uA_set = $WFR1->GetDieFieldSet(@dieset,"Vf_10_uA");
			my $Vf_x_uA = CheckLimits::CombineValSet(@Vf_x_uA_set,"Vf_10_uA");
			push(@Vf_x_uA_Good, $Vf_x_uA);
		}
	}				
				
	#Calculate Vf_x_uA mean, stdev, USL, LSL
		
	my %Stats_Vf_x_uA =  StatisticsLite::statshash(@Vf_x_uA_Good);
	my $Mean_Vf_x_uA = $Stats_Vf_x_uA{"mean"};
	my $Stdev_Vf_x_uA = $Stats_Vf_x_uA{"stddev"};
	$Vf_x_uA_Mean = $Mean_Vf_x_uA;
	$Vf_x_uA_Stdev = $Stdev_Vf_x_uA;
	$Vf_x_uA_USL = $Mean_Vf_x_uA + 3.5 * $Stdev_Vf_x_uA;	# 3.5 sigma
	$Vf_x_uA_LSL = $Mean_Vf_x_uA - 3.5 * $Stdev_Vf_x_uA;
		
	#print "Vf_x_uA_Mean: $Vf_x_uA_Mean\n";
	#print "Vf_x_uA_Stdev: $Vf_x_uA_Stdev\n";
	#print "Vf_x_uA_USL: $Vf_x_uA_USL\n";
	#print "Vf_x_uA_LSL: $Vf_x_uA_LSL\n";
			
	for( $arr=0; $arr < $numArrayLeds; $arr++)
	{
		#print " it goes in here 1 \n" ;
		ProductStructure::IsArrayComplete($arr) || next;
		@dieset = ProductStructure::GetDieSet4Array($arr);
	
		my $VISflag = 1;
		if($VISready)
		{  
			my @vflg = $WFR1->GetDieFieldSet(@dieset,"VISflag");
			$VISflag = $vflg[0];
		}
		if($BinStatus[$arr] == 1 && $VISflag == 1) # only collect values for standard good parts
		{
			#print " it goes in here 2/ \n" ;
			my @Vf_x_uA_set = $WFR1->GetDieFieldSet(@dieset,"Vf_10_uA");
			my $Vf_x_uA = CheckLimits::CombineValSet(@Vf_x_uA_set,"Vf_10_uA");
			if( $Vf_x_uA < $Vf_x_uA_LSL)
			{
				print " 1767 : $Vf_x_uA_LSL \n";
				print " 1768 : $Vf_x_uA \n";
				#my $ort= "ORT"; 
				my $LSL = sprintf("%0.5f", $Vf_x_uA_LSL);
				$Vf_x_uA_reject = "$Vf_x_uA\_LSL\_$LSL";
				$TotalGoodDie--;
				#$BinStatus[$arr] = 0;        
				$RejParetoCounts{"numLow_Vf_10_uA_Outlier"}++;
				
				$Vf_x_uA_OutlierCounts ++;
				$WFR1->ReplaceDieFieldSet(@dieset,"BinNum", 9976); 
				$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "FAIL_Low_Vf_10_uA_Outlier");
				#$WFR1->ReplaceDieFieldSet(@dieset,"PartID", "$L0Part$ort");
				$WFR1->ReplaceDieFieldSet(@dieset,"PnPBin", 0);
				$WFR1->ReplaceDieFieldSet(@dieset,"BinStatus",0);
				$WFR1->ReplaceDieFieldSet(@dieset,"OutlierReject", $Vf_x_uA_reject );
				next;
			}
		}
	}				
}

#--------------------------------------REPORTS------------------------------------------

sub DoReports # ()
{
	# Last bits of header field adjustments
	$WFR1->ReplaceHeaderField("VfLowLimit", CheckLimits::GetLowerProdLimit("VfLow"), "");
	$WFR1->ReplaceHeaderField("VfLowPostLimit", 0, "");

	$YieldBasis = ProductStructure::GetPStructHeaderField("YieldBasis"); # could be same as #arrays or less for Eos
    if( $YieldBasis >  $TotalVISrej )
    {
	   $NoSaberYield = ($TotalGoodDie/($YieldBasis - $TotalVISrej))*100.0;
    }
    else
    {
        $NoSaberYield = 0;
    }
	$TotalYield = ($TotalGoodDie/$YieldBasis)*100.0;

	# Generate the yield summary record for use by Summary() and WHYreport()
	$YieldSummaryRec = MavSummaryRecord();
    WFZgenerator();  # sets up $WFZRpt string used in WFZreport()

	# Generate reports
	my $rptdir = "$ExportsDir\\$RawLotName";
	mkdir $rptdir || die "Can't create directory $ExportsDir\\$RawLotName\n";
	Summary($rptdir) if($Summaries eq 'YES');
    WHYreport($rptdir) if($Summaries eq 'YES');
	WFRreport($rptdir);
    WFZreport($rptdir) if($Summaries eq 'YES');
    if($CVF_report eq 'YES')
    {
        CVFreport($rptdir);
    }

    if($IsProduct eq "Y")  # We only want to sort actual product devices
    {
        PnPreport($rptdir) if($Summaries eq 'YES');
        PnPSummary($rptdir) if($Summaries eq 'YES');
        TSMreport($rptdir);
        TSSreport($rptdir);
	RJreport($rptdir);
        if($TRM_STmaps eq 'YES')
        {
            TRMreport($rptdir);
        }
    }
	return 1;
}
	
sub Summary($) # ($reportdir)
{
	my $wfsfilepath = "$_[0]/WFS$WaferID.blu";
	print "WFS Rpt: $wfsfilepath\n";
	Win32::File::SetAttributes($wfsfilepath, NORMAL) if -e $wfsfilepath;
	open(WFSOUT, ">$wfsfilepath") || die "Can't open $wfsfilepath for writing!\n";

	print WFSOUT "Summary for $FileWafID\n"; # only the tileID to make file compares easier

	print WFSOUT "\nProduct Bin Summary minus Saber Visual Rejects\n";
	foreach my $category (sort keys %ProductBinCounts)
	{
		print WFSOUT "$category\t= ", $ProductBinCounts{$category}, "\n";
	}
	print  WFSOUT "Total Good Die           =\t$TotalGoodDie\n";
	printf WFSOUT "Yield minus VISrej =\t%.1f%%\n", $NoSaberYield;
	printf WFSOUT "Total Yield        =\t%.1f%%\n", $TotalYield ;

	my $FluxCount = 0;
	my $VfwdCount = 0;
	my $VfLowCount = 0;
	my $VrevCount = 0;
	my $ColorCount = 0;
	for( $arr=0; $arr < $numArrayLeds; $arr++)
	{
		# Count each lamp for its most important failure if any
		ProductStructure::IsArrayComplete($arr) || next;
		@dieset = ProductStructure::GetDieSet4Array($arr);
        my $VISflag = 1;
        if($VISready)
        {
            my @vflg = $WFR1->GetDieFieldSet(@dieset,"VISflag");
            $VISflag = $vflg[0];
        }
        if($VISflag)
        {
            my $dflags = CheckLimits::ShowDieFlagsSet(@dieset);
    		my @flags = split("",$dflags);
    		if($flags[0] == 0)
    		{
    			$VrevCount++;
    		}
    		elsif($flags[3] == 0)
    		{
    			$VfLowCount++;
    		}
    		elsif($flags[2] == 0)
    		{
    			$VfwdCount++;
    		}
    		elsif($flags[4] == 0)
    		{
    			$ColorCount++;
    		}
    		elsif($flags[1] == 0)
    		{
    			$FluxCount++;
    		}
        }
	}
	print WFSOUT "\nPriority Reject Summary\n";
	print WFSOUT "  Using Priority: VIS->Vrev->VfLow->Vfwd->Color->Flux\n";
	print WFSOUT "  Only 1 reject category per device is counted\n";
	print WFSOUT "VIS =\t$TotalVISrej\n";
	print WFSOUT "Vr =\t$VrevCount\n";
	print WFSOUT "VfLow =\t$VfLowCount\n";
	print WFSOUT "Vfwd =\t$VfwdCount\n";
	print WFSOUT "Color =\t$ColorCount\n";
	print WFSOUT "Flux =\t$FluxCount\n";
 
	print WFSOUT "Total Priority Rejects =\t",$FluxCount+$VfwdCount+$VfLowCount+$VrevCount+$ColorCount+$TotalVISrej,"\n";
	
	print WFSOUT "\nColor-only Reject Summary minus Saber Visual Rejects\n";
	foreach my $category (sort keys %ColorRejCounts)
	{
		print WFSOUT "$category\t= ", $ColorRejCounts{$category}, "\n";
	}
	print WFSOUT "\nFlux-only Reject Summary minus Saber Visual Rejects\n";
	foreach my $category (sort keys %IvRejCounts)
	{
		print WFSOUT "$category\t= ", $IvRejCounts{$category}, "\n";
	}
	print WFSOUT "\nColor+Flux Reject Summary minus Saber Visual Rejects\n";
	foreach my $category (sort keys %LightRejCounts)
	{
		print WFSOUT "$category\t= ", $LightRejCounts{$category}, "\n";
	}

	print WFSOUT "\nLimit Rejects Summary minus Saber Visual Rejects\n";
	my $LimitTotal = 0;
	foreach my $category (sort keys %LimitRejCounts)
	{
		print WFSOUT "$category\t= ", $LimitRejCounts{$category}, "\n";
		$LimitTotal += $LimitRejCounts{$category}
	}
	print WFSOUT "Limit Rejects Total= \t$LimitTotal\n";
	
    if($VISready)
    {
    	print WFSOUT "\nSaber Visual Rejects Summary\n";
    	my $VisRejTotal = 0;
    	foreach my $category (sort keys %VisRejCounts)
    	{
    		print WFSOUT "$category\t= ", $VisRejCounts{$category}, "\n";
    		$VisRejTotal += $VisRejCounts{$category}
    	}
    	print WFSOUT "Saber Visual Category Subtotals = \t$VisRejTotal\n";
    	print WFSOUT "Saber Visual Rejects Total      = \t$TotalVISrej\n";
    }

	# print Wafer Summary for Eos OR whole wafer, but not both
	print WFSOUT $YieldSummaryRec;  # with extra string-searchable identifiers for each line
	close WFSOUT;	
}

sub WHYreport($) # ($reportdir)   for Eos record export
{
	my $whyfilepath = "$_[0]/WHY$WaferID.blu";
	print "WHY Rpt: $whyfilepath\n";
	Win32::File::SetAttributes($whyfilepath, NORMAL) if -e $whyfilepath;
	open(WHYOUT, ">$whyfilepath") || die "Can't open $whyfilepath for writing!\n";
    my $whyrecord = $YieldSummaryRec; # record is set in DoReports();
	$whyrecord =~ s/\n\nEosLabels_v5\tLotID//g;  # strip the extra stuff for WHY file, including first label field
	$whyrecord =~ s/EosData_v5\t//g;  # the first label needs to be blank for the Blue DB importer
	print WHYOUT $whyrecord;
	close WHYOUT;
}

sub CVFreport ($) #($reportdir)
{
    # only do this report for WaferIDs containing -B[345]-T390-350
    if($WaferID !~ /^.*-B[345]-T390-350$/i)
    {
        return;
    }
    # open the report
	my $CVFfilepath = "$_[0]/CVF_$WaferID.txt";
	print "CVF Rpt: $CVFfilepath\n";
	Win32::File::SetAttributes($CVFfilepath, NORMAL) if -e $CVFfilepath;
	open(CVFOUT, ">$CVFfilepath") || die "Can't open $CVFfilepath for writing!\n";
    # extract the die bin number from TileID
    my $TileDieBin = $WaferID;
    $TileDieBin =~ s/^.*-B//i; # Strip everything before plus -B
    $TileDieBin =~ s/-T390-350$//i; # Strip everything after bin #
    # print the report
	for( $die=0; $die < $numdierecs; $die++)  # All die and array counting is ZERO-based
	{
		my $Vf = $WFR1->GetDieField($die, "Vf2");
   		my $PHIe = $WFR1->GetDieField($die, "PHIe");
        print CVFOUT "$TileDieBin\t$Vf\t$PHIe\n";
    }
    # close the report
	close CVFOUT;
}

sub MavSummaryRecord # () no args required, returns formatted 2 line record
{
	my %RejParetoCounts = (   # initialize every category in case some don't get hit below
		"numNoLight" => 0,
		"numLow_Vr" => 0,
		"numHigh_Vr" => 0,
		"numLow_VfLow" => 0,
		"numHigh_VfLow" => 0,
		"numLow_Vf_x_uA" => 0,
		"numHigh_Vf_x_uA" => 0,
		"numHigh_Vf" => 0,
		"numLow_Vf" => 0,
		"numWrongPump" => 0,
		"numLow_WL" => 0,
		"numHigh_WL" => 0,
		"numThickPhosphor" => 0,
		"numHighCCT" => 0,
		"numThinPhosphor" => 0,
		"numNoPhosphor" => 0,
		"numYellowTint" => 0,
		"numPinkTint" => 0,
		"numLow_Iv" => 0,
		"numHigh_Iv" => 0,
		"numLow_CRI" => 0,
		"numNo_RejCat" => 0,
		"numVisRej" => 0,
		"numBurn_In" => 0,
		"numNo_Color_Bin" => 0,
		"numLow_DVf_100uA" => 0,
		"numHigh_DVf_100uA" => 0,
		"numLow_Vr_10uA" => 0,
		"numHigh_Vr_10uA" => 0,
		"numNo_Flux_Bin" => 0,
		"numNo_Vf_Bin" => 0,
		"numOVM" => 0,
		"numLow_VfPost01" => 0,
		"numHigh_VfPost01" => 0,
		"numLow_PHIv_Outlier" => 0,
		"numLow_Vf2_Outlier" => 0,
		"numHigh_Vf2_Outlier" => 0,
		"numLow_Vf_10_uA_Outlier" => 0,
	);

	my  %RejBinName2BinNumber = (  # Permanently assigned reject bin numbers for the Rebel partition,
	   #official FAIL_ names for production AND Syntricity AND DCR reports
		"FAIL_No_Light" => 9900,
		"FAIL_Low_Vr" => 9901,
		"FAIL_Low_VfLow" => 9902,
		"FAIL_High_Vf" => 9903,
		"FAIL_Low_Vf" => 9904,
		"FAIL_WrongPump" => 9905,
		"FAIL_NoPhosphor" => 9906,
		"FAIL_ThinPhosphor" => 9907,
		"FAIL_HighCCT" => 9908,
		"FAIL_ThickPhosphor" => 9909,
		"FAIL_YellowTint" => 9910,
		"FAIL_PinkTint" => 9911,
		"FAIL_Low_Iv" => 9912,
		"FAIL_No_Color_Bin" => 9913,
		"FAIL_No_RejCat" => 9914,
		"FAIL_VISrej" => 9915,
		"FAIL_Test_VISrej" => 9916,
		"FAIL_Low_Vf_10_uA" => 9917,    # for 10uA Vf
		"FAIL_High_Vf_10_uA" => 9928,	# for 10uA Vf Added 15/12/2017 BP
		"FAIL_Low_CRI" => 9918,    # for CRI
		"FAIL_Low_Vf_20_uA" => 9919,    # for 20uA Vf
		"FAIL_High_Vf_20_uA" => 9943,    # for 20uA Vf
		"FAIL_Low_WL" => 9920,
		"FAIL_High_WL" => 9921,
		"FAIL_High_Vr" => 9922,
		"FAIL_High_VfLow" => 9923,
		"FAIL_Low_Vf_21_uA" => 9924,    # for 21uA Vf
		"FAIL_High_Vf_21_uA" => 9979, 
		"FAIL_High_Iv" => 9937,
		"FAIL_Burn_In" => 9036,
		"FAIL_Low_DVf_100uA" => 9940,
		"FAIL_High_DVf_100uA" => 9930,
		"FAIL_Low_Vr_10uA" => 9926,
		"FAIL_High_Vr_10uA" => 9927,
		"FAIL_No_Flux_Bin" => 9961,
		"FAIL_No_Vf_Bin" => 9960,
		"FAIL_Low_VfPost01" => 9966,
		"FAIL_High_VfPost01" => 9967,
		"FAIL_OTHERS" => 9999,
		"FAIL_Low_PHIv_Outlier" => 9976,
		"FAIL_Low_Vf2_Outlier" => 9997,
		"FAIL_High_Vf2_Outlier" => 9998,
		"FAIL_Low_Vf_10_uA_Outlier" => 9048,
	);

	my %Lp1Bins = (
		"LP430" => 0,
		"LP435" => 0,
		"LP440" => 0,  # B3
		"LP445" => 0,  # B4
		"LP450" => 0,  # B5
		"LP455" => 0,  # B6
		"LP460" => 0,
		"LP465" => 0 );

	my $numMavGood = 0;
	my ($Vf, $Vr, $VfLow, $uprime, $vprime, $CCT, $Lp1, $FR1e, $Vf_x_uA_value, $CRI, $Vr_10_uA);
	my ($VfPost01);
	my ($DVf04_02R, $DVf06_02R, $DVf08_02R, $DVf010_02R,$DVf012_02R, $DVf014_02R, $DVf016_02R, $DVf018_02R, $DVf020_02R, $DVf022_02R, $DVf024_02R, $DVf026_02R, $DVf028_02R, $DVf030_02R);
	my ($DVf03_01R, $DVf05_01R, $DVf07_01R, $DVf09_01R, $DVf011_01R, $DVf013_01R, $DVf015_01R, $DVf017_01R, $DVf019_01R, $DVf021_01R, $DVf023_01R, $DVf025_01R, $DVf027_01R, $DVf029_01R);
	my ($LambdaD, $LambdaP, $PHIv, $PHIe, $xled, $yled);  # working parametric value variables
	my ( $BinStat, $ct, $VISflag );
	my ( @MAP_Vr, @MAP_Vf, @MAP_VfLow, @MAP_Iv, @MAP_CCT, @MAP_uprime, @MAP_vprime, @MAP_FR1e);
	my ( @FUNC_CCT, @FUNC_uprime, @FUNC_vprime, $FUNC_DieCount) = ();;
	$FUNC_DieCount = 0;
	
	# Special filter and counting for Flamenco & Sequoia Eos submounts per Bob's criteria
	for( $die=0; $die < $numdierecs; $die++)  # All die and array counting is ZERO-based
	{
		$Vf = $WFR1->GetDieField($die, "Vf2");
		$Vr = $WFR1->GetDieField($die, "Vr");
		$VfLow = $WFR1->GetDieField($die, "VfLow");
		if($Color =~ /^(White).*/i) # a white product type,  also includes PC amber since that is box binned
		{
			#if ($L1Part =~ /^(F6NL5GV-2|F6NL5GV2-2|F6WNL5GV-2|DCLFES576502|DCLFES576501|DCLFES576503|DCLFES576504|DCLFFS576503|DCLFFS576501|DCLFFS576505|DCLFFS576504|DCLFFS576506)$/i)
			if ($L1Part =~ /^(F6NL5GV-2|F6NL5GV2-2|F6WNL5GV-2|DCLFES576502|DCLFES576501|DCLFES576503|DCLFES576504|DCLFFS576503|DCLFFS576501|DCLFFS576505|DCLFFS576504|DCLFFS576506|DCLFES576503|DCLFES576505|DCLFES576512|DCLFES576510|DCLFFS576510|DCLFES576513|DCLFES576515|DCLFES576516|DCLFFS576511|DCLFES576521|DCLFES576518|DCLFES576525|DCLFES576519|DCLFFS576512|DCLFES576514|DCLFES576517|DCLFES576528|DCLFES576523|DCLFES576530|DCLFFS576518|DCLFFS576513|DCLFES576532|DCLFFS576519|DCLFFS576517|DCLFES576529|DCLFES576531|DCLFES576537|DCLFES576541|DCLFES576540|DCLFES576539|DCLFES576537|DCLFES576538|DCLFFS576522|DCLFFS576521|DCLFFS576523|DCLFFS576524|DCLFES576542|DCLFES576544|DCLFES576545|DCLFES576546|DCLFES576547|DCLFES576548|DCLFES576549|DCLFES576550|DCLFFS576531|DCLFFS576532|DCLFFS576526|DCLFFS576536|DCLFFS576537|DCLFES576534|DCLFES576551|DCLFES576552|DCLFFS576529|DCLFFS576530|DCLFFS576528|DCLFES576553|DCLFES576554|DCLFES576555|DCLFES576556|DCLFRE576504|DCLFES576557|DCLFES576558|DCLFES576559|DCLFES576560|DCLFES576557|DCLFFS576530|DCLFEX576502|DCLFFS576527|DCLFFS576538|DCLFES576561|DCLFES576562|DCLFES576563|DCLFES576564|DCLFES576565|DCLFES576566|DCLFEX576501|DCLFFS576539|DCLFEX576503|DCLFEX576504|DCLFEX576505|DCLFFS576533|DCLFFS576534|DCLFFS576540|DCLFRE576505|DCLFRE576501|DCLFRE576509|DCLFRE576502)$/i)
			{
				if(!$WFR1->DieFieldExists("DVf04_02R"))
				{
					print "WFR does not contain data for DVf04_02R\n";
					return "";
				}
				if(!$WFR1->DieFieldExists("DVf06_02R"))
				{
					print "WFR does not contain data for DVf06_02R\n";
					return "";
				}
				if(!$WFR1->DieFieldExists("DVf08_02R"))
				{
					print "WFR does not contain data for DVf08_02R\n";
					return "";
				}
				if(!$WFR1->DieFieldExists("DVf010_02R"))
				{
					print "WFR does not contain data for DVf010_02R\n";
					return "";
				}
				if(!$WFR1->DieFieldExists("DVf012_02R"))
				{
					print "WFR does not contain data for DVf012_02R\n";
					return "";
				}
				if(!$WFR1->DieFieldExists("DVf014_02R"))
				{
					print "WFR does not contain data for DVf014_02R\n";
					return "";
				}
				if(!$WFR1->DieFieldExists("DVf016_02R"))
				{
					print "WFR does not contain data for DVf016_02R\n";
					return "";
				}
				if(!$WFR1->DieFieldExists("DVf018_02R"))
				{
					print "WFR does not contain data for DVf018_02R\n";
					return "";
				}
				if(!$WFR1->DieFieldExists("DVf020_02R"))
				{
					print "WFR does not contain data for DVf020_02R\n";
					return "";
				}
				if(!$WFR1->DieFieldExists("DVf022_02R"))
				{
					print "WFR does not contain data for DVf022_02R\n";
					return "";
				}
				if(!$WFR1->DieFieldExists("DVf024_02R"))
				{
					print "WFR does not contain data for DVf024_02R\n";
					return "";
				}
				if(!$WFR1->DieFieldExists("DVf026_02R"))
				{
					print "WFR does not contain data for DVf026_02R\n";
					return "";
				}
				
				if(!$WFR1->DieFieldExists("DVf028_02R"))
				{
					print "WFR does not contain data for DVf028_02R\n";
					return "";
				}
				if(!$WFR1->DieFieldExists("DVf030_02R"))
				{
					print "WFR does not contain data for DVf030_02R\n";
					return "";
				}
				$DVf04_02R = $WFR1->GetDieField($die, "DVf04_02R");
				$DVf06_02R = $WFR1->GetDieField($die, "DVf06_02R");
				$DVf08_02R = $WFR1->GetDieField($die, "DVf08_02R");
				$DVf010_02R = $WFR1->GetDieField($die, "DVf010_02R");
				$DVf012_02R = $WFR1->GetDieField($die, "DVf012_02R");
				$DVf014_02R = $WFR1->GetDieField($die, "DVf014_02R");
				$DVf016_02R = $WFR1->GetDieField($die, "DVf016_02R");
				$DVf018_02R = $WFR1->GetDieField($die, "DVf018_02R");
				$DVf020_02R = $WFR1->GetDieField($die, "DVf020_02R");
				$DVf022_02R = $WFR1->GetDieField($die, "DVf022_02R");
				$DVf024_02R = $WFR1->GetDieField($die, "DVf024_02R");
				$DVf026_02R = $WFR1->GetDieField($die, "DVf026_02R");
				$DVf028_02R = $WFR1->GetDieField($die, "DVf028_02R");
				$DVf030_02R = $WFR1->GetDieField($die, "DVf030_02R");
			}
			
			$CCT = $WFR1->GetDieField($die, "CCT");
			$PHIv = $WFR1->GetDieField($die, "PHIv");
			$Lp1 = $WFR1->GetDieField($die, "Lp1");
			$FR1e = $WFR1->GetDieField($die, "FR1e");
			$uprime = $WFR1->GetDieField($die, "u_prime");
			$vprime = $WFR1->GetDieField($die, "v_prime");
			$xled = $WFR1->GetDieField($die,"Xled");   # in case we have to do elliptical binning
			$yled = $WFR1->GetDieField($die,"Yled");
			if($WFR1->DieFieldExists("CRI")) # in case WFR*.blu doesn't have CRI and is PC amber
			{
				$CRI = $WFR1->GetDieField($die, "CRI");
			}
			
		}
		else   # non-white
		{
			$PHIe = $WFR1->GetDieField($die, "PHIe");
			$PHIv = $WFR1->GetDieField($die, "PHIv");
			$LambdaD = $WFR1->GetDieField($die, "LambdaD");
			$LambdaP = $WFR1->GetDieField($die, "LambdaP");
		}
		if($WFR1->DieFieldExists("$Vf_x_uA_name")) # in case WFR*.blu doesn't have Vf_x_uA
		{
			$Vf_x_uA_value = $WFR1->GetDieField($die,"$Vf_x_uA_name");
		}
		if($WFR1->DieFieldExists("Vr_10_uA")) # in case WFR*.blu doesn't have Vr_10_uA
		{
			$Vr_10_uA = $WFR1->GetDieField($die,"Vr_10_uA");
		}
		$VISflag = 1;
		if($VISready)
		{
			$VISflag = $WFR1->GetDieField($die,"VISflag");
		}
		elsif($VISflag == 2)
		{
		$WFR1->ReplaceDieField($die,"PartID", "FAIL_Burn_In");
		}
		$BinStat = $WFR1->GetDieField($die,"BinStatus");
		if($BinStat == 1 && $VISflag == 1) # stats for parts that ended up as shipped
		{
			if($Color =~ /^(White).*/i) # a white product type
			{
				push(@MAP_Vr, $Vr);
				push(@MAP_Vf, $Vf);
				push(@MAP_VfLow, $VfLow);
				push(@MAP_Iv, $PHIv);
				push(@MAP_CCT, $CCT);
				push(@MAP_uprime, $uprime);
				push(@MAP_vprime, $vprime);
				push(@MAP_FR1e, $FR1e);
			}
			else     # non-white
			{
				push(@MAP_Vr, $Vr);
				push(@MAP_Vf, $Vf);
				push(@MAP_VfLow, $VfLow);
				push(@MAP_Iv, $PHIv);
			}
		}
		if(($Color =~ /^(White).*/i) && $VISflag == 1  && $BinStat == 1 || $BinStat < 0)
		{  # stats for white goods & color/intensity rejects only,  good parts added 3/10/04
			push(@FUNC_CCT, $CCT);
			push(@FUNC_uprime, $uprime);
			push(@FUNC_vprime, $vprime);
			$FUNC_DieCount ++;
			my $BinnedLp1 = int($Lp1/5.0)*5.0;   # bins into 5 nm buckets
			$Lp1Bins{"LP$BinnedLp1"}++;  # only electrically good devices counted
			# hash might include bins beyond init keys.  Don't care about these.
		}


		# Do not send any Saber Visual Rejects through the reject pareto.
		if(($Color =~ /^(White).*/i) && ($RadioPhoto =~ /^(Photo).*/i) && $BinStat < 1 && $VISflag == 1) # a white product type or PCamber
		{          # Can do either 350 or 1000 mA, don't try to classify good parts.
			if($EllipseBinning == 1)
			{  # get the ellipse bin color code (2 characters), using Xled and
			   #Yled because that's how the specs are supplied. We primarily want to
			   #have the color reject code. Why can't we keep the original ct for
			   #every die found in regular binning?
				$ct = EllipseBinner::EllipseBin($xled,$yled);  
			}
			else
			{
				$ct = BoxBinner::BoxBin($uprime,$vprime);  # get the box bin color code (2 characters)
			}
			if($VISflag == 2)
			{
				$TotalVISrej++;
				$RejParetoCounts{"numBurn_In"}++;
                                $BinStatus[$arr] = 0;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Burn_In");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Burn_In"});
				next;
			}
			if($PHIv	< 2.0) # per Ed 12/8/04
			{
				$RejParetoCounts{"numNoLight"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Light");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Light"});
				next;
			}
			if($Vr	> CheckLimits::GetUpperProdLimit("Vr"))
			{
				$RejParetoCounts{"numLow_Vr"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Vr");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Vr"});
				next;
			}
			if($Vr	< CheckLimits::GetLowerProdLimit("Vr"))
			{
				$RejParetoCounts{"numHigh_Vr"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Vr");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Vr"});
				next;
			}
			if($WFR1->DieFieldExists("Vr_10_uA"))
			{
				if($Vr_10_uA > CheckLimits::GetUpperProdLimit("Vr_10_uA"))
				{
					$RejParetoCounts{"numLow_Vr_10uA"}++;
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Vr_10uA");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Vr_10uA"});
					next;
				}
				if($Vr_10_uA < CheckLimits::GetLowerProdLimit("Vr_10_uA"))
				{
					$RejParetoCounts{"numHigh_Vr_10uA"}++;
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Vr_10uA");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Vr_10uA"});
					next;
				}
			}
			if($VfLow < CheckLimits::GetLowerProdLimit("VfLow"))
			{
				$RejParetoCounts{"numLow_VfLow"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_VfLow");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_VfLow"});
				next;
			}
			if($VfLow > CheckLimits::GetUpperProdLimit("VfLow"))
			{
				$RejParetoCounts{"numHigh_VfLow"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_VfLow");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_VfLow"});
				next;
			}
			if($WFR1->DieFieldExists("$Vf_x_uA_name")) # in case WFR*.blu doesn't have Vf_x_uA
			{
				if($Vf_x_uA_value < CheckLimits::GetLowerProdLimit("$Vf_x_uA_name"))
				{
					$RejParetoCounts{"numLow_Vf_x_uA"}++;  # gets its own category
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_$Vf_x_uA_name");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_$Vf_x_uA_name"});
					next;
				}
			}
			if($WFR1->DieFieldExists("$Vf_x_uA_name")) # in case WFR*.blu doesn't have Vf_x_uA
			{
				if($Vf_x_uA_value > CheckLimits::GetUpperProdLimit("$Vf_x_uA_name"))
				{
					$RejParetoCounts{"numHigh_Vf_x_uA"}++;  # gets its own category
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_$Vf_x_uA_name");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_$Vf_x_uA_name"});
					next;
				}
			}
			if($Vf >  CheckLimits::GetUpperProdLimit("Vf2"))
			{
				$RejParetoCounts{"numHigh_Vf"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Vf");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Vf"});
				next;
			}

			if($Vf < CheckLimits::GetLowerProdLimit("Vf2"))
			{
				$RejParetoCounts{"numLow_Vf"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Vf");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Vf"});
				next;
			}
			#if($Lp1	<  CheckLimits::GetLowerProdLimit("Lp1") || $Lp1 >  CheckLimits::GetUpperProdLimit("Lp1"))
			#{
				#$RejParetoCounts{"numWrongPump"}++;
				#$WFR1->ReplaceDieField($die,"PartID", "FAIL_WrongPump");
				#$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_WrongPump"});
				#next;
			#}
			if($ct eq "ZB" && $BinStat != 0)
			{
				$RejParetoCounts{"numNoPhosphor"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_NoPhosphor");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_NoPhosphor"});
				next;
			}
			if($ct eq "ZN" && $BinStat != 0)
			{
				$RejParetoCounts{"numThinPhosphor"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_ThinPhosphor");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_ThinPhosphor"});
				next;
			}
			if($ct eq "ZH" && $BinStat != 0 )
			{
				$RejParetoCounts{"numHighCCT"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_HighCCT");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_HighCCT"});
				next;
			}
			if($ct eq "ZK" && $BinStat != 0)
			{
				$RejParetoCounts{"numThickPhosphor"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_ThickPhosphor");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_ThickPhosphor"});
				next;
			}
			if($ct eq "ZG" && $BinStat != 0)
			{
				$RejParetoCounts{"numYellowTint"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_YellowTint");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_YellowTint"});
				next;
			}
			if($ct eq "ZP"  && $BinStat != 0)
			{
				$RejParetoCounts{"numPinkTint"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_PinkTint");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_PinkTint"});
				next;
			}
			#if($ct eq "ZO"  && $BinStat != 0)  # new category of unwanted region but no direction specified
			#{
			#	$RejParetoCounts{"numNo_Color_Bin"}++;
			#	$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Color_Bin");
			#	$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Color_Bin"});
			#	next;
			#}
			if($PHIv < CheckLimits::GetLowerProdLimit("PHIv"))  # cleanup of limits switched from Iv to PHIv
			{
				$RejParetoCounts{"numLow_Iv"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Iv");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Iv"});
				next;
			}
			if($PHIv > CheckLimits::GetUpperProdLimit("PHIv"))  # cleanup of limits switched from Iv to PHIv
			{
				$RejParetoCounts{"numHigh_Iv"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Iv");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Iv"});
				next;
			}
			if($WFR1->DieFieldExists("CRI")) # in case WFR*.blu doesn't have CRI and is PC amber
			{
				if($CRI < CheckLimits::GetLowerProdLimit("CRI"))  
				{
					$RejParetoCounts{"numLow_CRI"}++;
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_CRI");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_CRI"});
					next;
				}
			}
			#if($BinStat < 0)  # any remaining color &or flux &or vf bin rejects -3 not trapped by ZO, Vf -5, or -2
			#{
			#	$RejParetoCounts{"numNo_Color_Bin"}++;
			#	#$numMavGood--;
			#	$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Color_Bin");
			#	$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Color_Bin"});
			#	next;
			#}
			if($BinStat == -5)  # No_Vf_Bin
			{
				$RejParetoCounts{"numNo_Vf_Bin"}++;
				#$numMavGood--;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Vf_Bin");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Vf_Bin"});
				$WFR1->ReplaceDieFieldSet($die,"PnPBin", 0);
				next;
			}
			elsif($BinStat == -2)  # No_Flux_Bin
			{
				$RejParetoCounts{"numNo_Flux_Bin"}++;
				#$numMavGood--;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Flux_Bin");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Flux_Bin"});
				next;
			}
			elsif($BinStat == -1 || $BinStat == -3)  # No_Color_Bin and unknown bin
			{
				$RejParetoCounts{"numNo_Color_Bin"}++;
				#$numMavGood--;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Color_Bin");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Color_Bin"});
				next;
			}
			
			#if ($L1Part =~ /^(F6NL5GV-2|F6NL5GV2-2|F6WNL5GV-2|DCLFES576502|DCLFES576501|DCLFES576503|DCLFES576504|DCLFFS576503|DCLFFS576501|DCLFFS576505|DCLFFS576504|DCLFFS576506|DCLFES576503|DCLFES576505|DCLFES576512|DCLFES576510|DCLFFS576510|DCLFES576513|DCLFES576515|DCLFES576516|DCLFFS576511|DCLFES576521|DCLFES576518|DCLFES576525|DCLFES576519|DCLFFS576512|DCLFES576514|DCLFES576517|DCLFES576528|DCLFES576523|DCLFES576530|DCLFFS576518|DCLFFS576513|DCLFES576532|DCLFFS576519|DCLFFS576517|DCLFES576529|DCLFES576531|DCLFES576537|DCLFES576541|DCLFES576540|DCLFES576539|DCLFES576537|DCLFES576538|DCLFFS576522|DCLFFS576518|DCLFFS576523|DCLFFS576524|DCLFES576542|DCLFES576544|DCLFES576545|DCLFES576557)$/i)
			if ($L1Part =~ /^(F6NL5GV-2|F6NL5GV2-2|F6WNL5GV-2|DCLFES576502|DCLFES576501|DCLFES576503|DCLFES576504|DCLFFS576503|DCLFFS576501|DCLFFS576505|DCLFFS576504|DCLFFS576506|DCLFES576503|DCLFES576505|DCLFES576512|DCLFES576510|DCLFFS576510|DCLFES576513|DCLFES576515|DCLFES576516|DCLFFS576511|DCLFES576521|DCLFES576518|DCLFES576525|DCLFES576519|DCLFFS576512|DCLFES576514|DCLFES576517|DCLFES576528|DCLFES576523|DCLFES576530|DCLFFS576518|DCLFFS576513|DCLFES576532|DCLFFS576519|DCLFFS576517|DCLFES576529|DCLFES576531|DCLFES576537|DCLFES576541|DCLFES576540|DCLFES576539|DCLFES576537|DCLFES576538|DCLFFS576522|DCLFFS576521|DCLFFS576523|DCLFFS576524|DCLFES576542|DCLFES576544|DCLFES576545|DCLFES576546|DCLFES576547|DCLFES576548|DCLFES576549|DCLFES576550|DCLFFS576531|DCLFFS576532|DCLFFS576526|DCLFFS576536|DCLFFS576537|DCLFES576534|DCLFES576551|DCLFES576552|DCLFFS576529|DCLFFS576530|DCLFFS576528|DCLFES576553|DCLFES576554|DCLFES576555|DCLFES576556|DCLFRE576504|DCLFES576557|DCLFES576558|DCLFES576559|DCLFES576560|DCLFES576557|DCLFFS576530|DCLFEX576502|DCLFFS576527|DCLFFS576538|DCLFES576561|DCLFES576562|DCLFES576563|DCLFES576564|DCLFES576565|DCLFES576566|DCLFEX576501|DCLFFS576539|DCLFEX576503|DCLFEX576504|DCLFEX576505|DCLFFS576533|DCLFFS576534|DCLFFS576540|DCLFRE576505|DCLFRE576501|DCLFRE576509|DCLFRE576502)$/i)
			{
			
				if($WFR1->DieFieldExists("DVf04_02R"))
				{
					if($DVf04_02R <= CheckLimits::GetLowerProdLimit("DVf04_02R"))
					{
						$RejParetoCounts{"numLow_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_DVf_100uA"});
						#print "A\n";
						next;
					}
					if($DVf04_02R >= CheckLimits::GetUpperProdLimit("DVf04_02R"))
					{
						$RejParetoCounts{"numHigh_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_DVf_100uA"});
						next;
					}
				}
				if($WFR1->DieFieldExists("DVf06_02R"))
				{
					if($DVf06_02R <= CheckLimits::GetLowerProdLimit("DVf06_02R"))
					{
						$RejParetoCounts{"numLow_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_DVf_100uA"});
						next;
					}
					if($DVf06_02R >= CheckLimits::GetUpperProdLimit("DVf06_02R"))
					{
						$RejParetoCounts{"numHigh_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_DVf_100uA"});
						next;
					}
				}
				if($WFR1->DieFieldExists("DVf08_02R"))
				{
					if($DVf08_02R <= CheckLimits::GetLowerProdLimit("DVf08_02R"))
					{
						$RejParetoCounts{"numLow_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_DVf_100uA"});
						next;
					}
					if($DVf08_02R >= CheckLimits::GetUpperProdLimit("DVf08_02R"))
					{
						$RejParetoCounts{"numHigh_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_DVf_100uA"});
						next;
					}
				}
				if($WFR1->DieFieldExists("DVf010_02R"))
				{
					if($DVf010_02R <= CheckLimits::GetLowerProdLimit("DVf010_02R"))
					{
						$RejParetoCounts{"numLow_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_DVf_100uA"});
						next;
					}
					if($DVf010_02R >= CheckLimits::GetUpperProdLimit("DVf010_02R"))
					{
						$RejParetoCounts{"numHigh_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_DVf_100uA"});
						next;
					}
				}
				if($WFR1->DieFieldExists("DVf012_02R"))
				{
					if($DVf012_02R <= CheckLimits::GetLowerProdLimit("DVf012_02R"))
					{
						$RejParetoCounts{"numLow_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_DVf_100uA"});
						#print "A\n";
						next;
					}
					if($DVf012_02R >= CheckLimits::GetUpperProdLimit("DVf012_02R"))
					{
						$RejParetoCounts{"numHigh_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_DVf_100uA"});
						next;
					}
				}
				if($WFR1->DieFieldExists("DVf014_02R"))
				{
					if($DVf014_02R <= CheckLimits::GetLowerProdLimit("DVf014_02R"))
					{
						$RejParetoCounts{"numLow_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_DVf_100uA"});
						next;
					}
					if($DVf014_02R >= CheckLimits::GetUpperProdLimit("DVf014_02R"))
					{
						$RejParetoCounts{"numHigh_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_DVf_100uA"});
						next;
					}
				}
				if($WFR1->DieFieldExists("DVf016_02R"))
				{
					if($DVf016_02R <= CheckLimits::GetLowerProdLimit("DVf016_02R"))
					{
						$RejParetoCounts{"numLow_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_DVf_100uA"});
						next;
					}
					if($DVf016_02R >= CheckLimits::GetUpperProdLimit("DVf016_02R"))
					{
						$RejParetoCounts{"numHigh_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_DVf_100uA"});
						next;
					}
				}
				if($WFR1->DieFieldExists("DVf018_02R"))
				{
					if($DVf018_02R <= CheckLimits::GetLowerProdLimit("DVf018_02R"))
					{
						$RejParetoCounts{"numLow_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_DVf_100uA"});
						next;
					}
					if($DVf018_02R >= CheckLimits::GetUpperProdLimit("DVf018_02R"))
					{
						$RejParetoCounts{"numHigh_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_DVf_100uA"});
						next;
					}
				}
				if($WFR1->DieFieldExists("DVf020_02R"))
				{
					if($DVf020_02R <= CheckLimits::GetLowerProdLimit("DVf020_02R"))
					{
						$RejParetoCounts{"numLow_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_DVf_100uA"});
						next;
					}
					if($DVf020_02R >= CheckLimits::GetUpperProdLimit("DVf020_02R"))
					{
						$RejParetoCounts{"numHigh_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_DVf_100uA"});
						next;
					}
				}
				if($WFR1->DieFieldExists("DVf022_02R"))
				{
					if($DVf022_02R <= CheckLimits::GetLowerProdLimit("DVf022_02R"))
					{
						$RejParetoCounts{"numLow_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_DVf_100uA"});
						next;
					}
					if($DVf022_02R >= CheckLimits::GetUpperProdLimit("DVf022_02R"))
					{
						$RejParetoCounts{"numHigh_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_DVf_100uA"});
						next;
					}
				}
				if($WFR1->DieFieldExists("DVf024_02R"))
				{
					if($DVf024_02R <= CheckLimits::GetLowerProdLimit("DVf024_02R"))
					{
						$RejParetoCounts{"numLow_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_DVf_100uA"});
						next;
					}
					if($DVf024_02R >= CheckLimits::GetUpperProdLimit("DVf024_02R"))
					{
						$RejParetoCounts{"numHigh_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_DVf_100uA"});
						next;
					}
				}
				if($WFR1->DieFieldExists("DVf026_02R"))
				{
					if($DVf026_02R <= CheckLimits::GetLowerProdLimit("DVf026_02R"))
					{
						$RejParetoCounts{"numLow_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_DVf_100uA"});
						next;
					}
					if($DVf026_02R >= CheckLimits::GetUpperProdLimit("DVf026_02R"))
					{
						$RejParetoCounts{"numHigh_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_DVf_100uA"});
						next;
					}
				}
				if($WFR1->DieFieldExists("DVf028_02R"))
				{
					if($DVf028_02R <= CheckLimits::GetLowerProdLimit("DVf028_02R"))
					{
						$RejParetoCounts{"numLow_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_DVf_100uA"});
						next;
					}
					if($DVf028_02R >= CheckLimits::GetUpperProdLimit("DVf028_02R"))
					{
						$RejParetoCounts{"numHigh_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_DVf_100uA"});
						next;
					}
				}
				if($WFR1->DieFieldExists("DVf030_02R"))
				{
					if($DVf030_02R <= CheckLimits::GetLowerProdLimit("DVf030_02R"))
					{
						$RejParetoCounts{"numLow_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_DVf_100uA"});
						next;
					}
					if($DVf030_02R >= CheckLimits::GetUpperProdLimit("DVf030_02R"))
					{
						$RejParetoCounts{"numHigh_DVf_100uA"}++;
						$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_DVf_100uA");
						$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_DVf_100uA"});
						next;
					}
				}
				
			}	
			if($WFR1->DieFieldExists("VfPost01"))
			{
				if($VfPost01 < CheckLimits::GetLowerProdLimit("VfPost01"))
				
				{
					$RejParetoCounts{"numLow_VfPost01"}++;
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_VfPost01");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_VfPost01"});
					next;
				}
				if($VfPost01 > CheckLimits::GetUpperProdLimit("VfPost01"))
				
				{
					$RejParetoCounts{"numHigh_VfPost01"}++;
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_VfPost01");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_VfPost01"});
					next;
				}
			}
			if($L1Part =~ /^(DCLFFLPANC12|DCLFFLPANC08|DCLFFLPANC16|DCLFFLPANC15|DCLFFLPANC01|DCLFFLPANC05|DCLFFLPANC04|DCLFFLPANC07|DCLFFLPANC13|DCLFFLPANC14|DCLFFLPANC21|DCLFFLPANC22|DCLFFLPANC23|DCLFFLPANC18|DCLFFLPANC26|DCLFFLPANC17|DCLFFLPANC34|DCLFFLPANC48|DCLFFLPANC46|DCLFFLPANC45|DCLFFLPANC47|DCLFFLPANC44|DCLFFLPANC43|DCLFFLPANC41|DCLFFLPANC25|DCLFFLPANC42|DCLFFLPANC35|DCLFFLPANC38|DCLFFLPANC36|DCLFFLPANC40|DCLFFLPANC24|DCLFFLPANC39|DCLFFLPANC37|DCLFFLPANC52|DCLFFLPANC50|F6NL9XL-2|DCLFFLPANC02|DCLFFLPANC03|DCLFFLPANC09|DCLFFLPANC10|DCLFFLPANC11|DCLFFLPANC49|DCLFFLPANC33|DCLFFLPANC20|DCLFFLPANC59|DCLFFLPANC63|DCLFFLPANC64|DCLFFLPANC65|DCLFFLPANC66|DCLFFLPANC67|DCLFFLPANC68|DCLFFLPANC69|DCLFFLPANC70|DCLFFLPANC71|DCLFFLPANC72|DCLFFLPANC73|DCLFFLPANC74|DCLFFLPANC75|DCLFFLPANC76)/i) #Rebel PCA parts
			{	
				my $PartID = $WFR1->GetDieField($die, "PartID");
				if($PartID eq "FAIL_Low_PHIv_Outlier")
				{
					$RejParetoCounts{"numLow_PHIv_Outlier"}++;  # Leave the partID and BinNum alone, already set by ApplyPHIvMaverick()
					next;
				}
			}
			if($L1Part =~ /^(DCLFFLPANC34|DCLFFLPANC35|DCLFFLPANC36|DCLFFLPANC37|DCLFFLPANC38|DCLFFLPANC39|DCLFFLPANC40|DCLFFLPANC42|DCLFFLPANC69)/i) #Rebel PCA parts
			{	
				my $PartID = $WFR1->GetDieField($die, "PartID");
				if($PartID eq "FAIL_High_Vf2_Outlier")
				{
					$RejParetoCounts{"numHigh_Vf2_Outlier"}++;  # Leave the partID and BinNum alone, already set by ApplyPHIvMaverick()
					next;
				}
			}
			if ($L1Part =~ /^(DCLFFL576536.*)$/i) #DCLFFLPANC
			{
				my $PartID = $WFR1->GetDieField($die, "PartID");
				if($PartID eq "FAIL_Low_Vf_10_uA_Outlier")
				{
					$RejParetoCounts{"numLow_Vf_10_uA_Outlier"}++;  # Leave the partID and BinNum alone, already set by ApplyPHIvMaverick()
					next;
				}				
			}	
			else
			{    # don't count it bad or good, EosGood should always equal Shipping Qty
				$RejParetoCounts{"numNo_RejCat"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_RejCat");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_RejCat"});
				#print LOG "Reject not classified for $FullWFRpath, die $die, binstat $BinStat\n";
				#print     "Reject not classified for die $die, binstat $BinStat\n";
				next;
			
			}
		}
		elsif(($RadioPhoto =~ /^(Radio).*/i) && !($Color =~ /^(White).*/i) && $BinStat < 1 && $VISflag == 1 ) # Radiometric single color
		{                                 # Can do either 350 or 1000 mA
			if($PHIe < 2.0)
			{
				$RejParetoCounts{"numNoLight"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Light");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Light"});
				next;
			}
			if($Vr	> CheckLimits::GetUpperProdLimit("Vr"))
			{
				$RejParetoCounts{"numLow_Vr"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Vr");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Vr"});
				next;
			}
			if($Vr	< CheckLimits::GetLowerProdLimit("Vr"))
			{
				$RejParetoCounts{"numHigh_Vr"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Vr");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Vr"});
				next;
			}
			if($WFR1->DieFieldExists("Vr_10_uA"))
			{
				if($Vr_10_uA > CheckLimits::GetUpperProdLimit("Vr_10_uA"))
				{
					$RejParetoCounts{"numLow_Vr_10uA"}++;
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Vr_10uA");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Vr_10uA"});
					next;
				}
				if($Vr_10_uA < CheckLimits::GetLowerProdLimit("Vr_10_uA"))
				{
					$RejParetoCounts{"numHigh_Vr_10uA"}++;
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Vr_10uA");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Vr_10uA"});
					next;
				}
			}
			if($VfLow < CheckLimits::GetLowerProdLimit("VfLow"))
			{
				$RejParetoCounts{"numLow_VfLow"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_VfLow");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_VfLow"});
				next;
			}
			if($VfLow > CheckLimits::GetUpperProdLimit("VfLow"))
			{
				$RejParetoCounts{"numHigh_VfLow"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_VfLow");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_VfLow"});
				next;
			}
			if($WFR1->DieFieldExists("$Vf_x_uA_name")) # in case WFR*.blu doesn't have Vf_x_uA
			{
				if($Vf_x_uA_value < CheckLimits::GetLowerProdLimit("$Vf_x_uA_name"))
				{
					$RejParetoCounts{"numLow_Vf_x_uA"}++;  # gets its own category
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_$Vf_x_uA_name");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_$Vf_x_uA_name"});
					next;
				}
			}
			if($WFR1->DieFieldExists("$Vf_x_uA_name")) # in case WFR*.blu doesn't have Vf_x_uA
			{
				if($Vf_x_uA_value > CheckLimits::GetUpperProdLimit("$Vf_x_uA_name"))
				{
					$RejParetoCounts{"numHigh_Vf_x_uA"}++;  # gets its own category
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_$Vf_x_uA_name");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_$Vf_x_uA_name"});
					next;
				}
			}
			if($Vf >  CheckLimits::GetUpperProdLimit("Vf2"))
			{
				$RejParetoCounts{"numHigh_Vf"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Vf");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Vf"});
				next;
			}
			if($Vf < CheckLimits::GetLowerProdLimit("Vf2"))
			{
				$RejParetoCounts{"numLow_Vf"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Vf");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Vf"});
				next;
			}
			if($LambdaP	<  CheckLimits::GetLowerProdLimit("LambdaP"))
			{
				$RejParetoCounts{"numLow_WL"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_WL");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_WL"});
				next;
			}
			if($LambdaP >  CheckLimits::GetUpperProdLimit("LambdaP"))
			{
				$RejParetoCounts{"numHigh_WL"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_WL");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_WL"});
				next;
			}
			if($PHIe < CheckLimits::GetLowerProdLimit("PHIe"))  # cleanup of limits switched from Iv to PHIv
			{
				$RejParetoCounts{"numLow_Iv"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Iv");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Iv"});
				next;
			}
			if($PHIe > CheckLimits::GetUpperProdLimit("PHIe"))  # cleanup of limits switched from Iv to PHIv
			{
				$RejParetoCounts{"numHigh_Iv"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Iv");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Iv"});
				next;
			}
			#if($BinStat < 0)
			#{
			#	$RejParetoCounts{"numNo_Color_Bin"}++;
			#	$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Color_Bin");
			#	$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Color_Bin"});
			#	next;
			#}
			if($BinStat == -5)  # No_Vf_Bin
			{
				$RejParetoCounts{"numNo_Vf_Bin"}++;
				#$numMavGood--;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Vf_Bin");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Vf_Bin"});
				$WFR1->ReplaceDieFieldSet($die,"PnPBin", 0);
				next;
			}
			elsif($BinStat == -2)  # No_Flux_Bin
			{
				$RejParetoCounts{"numNo_Flux_Bin"}++;
				#$numMavGood--;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Flux_Bin");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Flux_Bin"});
				next;
			}
			elsif($BinStat == -1 || $BinStat == -3)  # No_Color_Bin and unknown bin
			{
				$RejParetoCounts{"numNo_Color_Bin"}++;
				#$numMavGood--;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Color_Bin");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Color_Bin"});
				next;
			}
			else
			{    # don't count it bad or good, EosGood should always equal Shipping Qty
				$RejParetoCounts{"numNo_RejCat"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_RejCat");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_RejCat"});
				 #print LOG "Reject not classified for $FullWFRpath, die $die, binstat $BinStat\n";
				#print     "Reject not classified for die $die, binstat $BinStat\n";
				#$numMavGood--;
				next;
			}
		}
		elsif(($RadioPhoto =~ /^(Photo).*/i) && !($Color =~ /^(White).*/i) && $BinStat < 1 && $VISflag == 1 ) # Photometric single color
		{                                 # Can do either 350 or 1000 mA
			if($PHIv < 2.0)
			{
				$RejParetoCounts{"numNoLight"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Light");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Light"});
				next;
			}
			if($Vr	> CheckLimits::GetUpperProdLimit("Vr"))
			{
				$RejParetoCounts{"numLow_Vr"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Vr");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Vr"});
				next;
			}
			if($Vr	< CheckLimits::GetLowerProdLimit("Vr"))
			{
				$RejParetoCounts{"numHigh_Vr"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Vr");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Vr"});
				next;
			}
			if($WFR1->DieFieldExists("Vr_10_uA"))
			{
				if($Vr_10_uA > CheckLimits::GetUpperProdLimit("Vr_10_uA"))
				{
					$RejParetoCounts{"numLow_Vr_10uA"}++;
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Vr_10uA");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Vr_10uA"});
					next;
				}
				if($Vr_10_uA < CheckLimits::GetLowerProdLimit("Vr_10_uA"))
				{
					$RejParetoCounts{"numHigh_Vr_10uA"}++;
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Vr_10uA");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Vr_10uA"});
					next;
				}
			}
			if($VfLow < CheckLimits::GetLowerProdLimit("VfLow"))
			{
				$RejParetoCounts{"numLow_VfLow"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_VfLow");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_VfLow"});
				next;
			}
			if($VfLow > CheckLimits::GetUpperProdLimit("VfLow"))
			{
				$RejParetoCounts{"numHigh_VfLow"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_VfLow");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_VfLow"});
				next;
			}
			if($WFR1->DieFieldExists("$Vf_x_uA_name")) # in case WFR*.blu doesn't have Vf_x_uA
			{
				if($Vf_x_uA_value < CheckLimits::GetLowerProdLimit("$Vf_x_uA_name"))
				{
					$RejParetoCounts{"numLow_Vf_x_uA"}++;  # gets its own category
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_$Vf_x_uA_name");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_$Vf_x_uA_name"});
					next;
				}
			}
			if($WFR1->DieFieldExists("$Vf_x_uA_name")) # in case WFR*.blu doesn't have Vf_x_uA
			{
				if($Vf_x_uA_value > CheckLimits::GetUpperProdLimit("$Vf_x_uA_name"))
				{
					$RejParetoCounts{"numHigh_Vf_x_uA"}++;  # gets its own category
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_$Vf_x_uA_name");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_$Vf_x_uA_name"});
					next;
				}
			}
			if($Vf >  CheckLimits::GetUpperProdLimit("Vf2"))
			{
				$RejParetoCounts{"numHigh_Vf"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Vf");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Vf"});
				next;
			}
			if($Vf < CheckLimits::GetLowerProdLimit("Vf2"))
			{
				$RejParetoCounts{"numLow_Vf"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Vf");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Vf"});
				next;
			}
			
			if($LambdaD	<  CheckLimits::GetLowerProdLimit("LambdaD"))
			{
				$RejParetoCounts{"numLow_WL"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_WL");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_WL"});
				next;
			}
			if($LambdaD >  CheckLimits::GetUpperProdLimit("LambdaD"))
			{
				$RejParetoCounts{"numHigh_WL"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_WL");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_WL"});
				next;
			}
			if($PHIv < CheckLimits::GetLowerProdLimit("PHIv"))  # cleanup of limits switched from Iv to PHIv
			{
				$RejParetoCounts{"numLow_Iv"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Iv");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Iv"});
				next;
			}
			if($PHIv > CheckLimits::GetUpperProdLimit("PHIv"))  # cleanup of limits switched from Iv to PHIv
			{
				$RejParetoCounts{"numHigh_Iv"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Iv");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Iv"});
				next;
			}
			#if($BinStat < 0)
			#{
			#	$RejParetoCounts{"numNo_Color_Bin"}++;
			#	$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Color_Bin");
			#	$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Color_Bin"});
			#	next;
			#}
			if($BinStat == -5)  # No_Vf_Bin
			{
				$RejParetoCounts{"numNo_Vf_Bin"}++;
				#$numMavGood--;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Vf_Bin");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Vf_Bin"});
				$WFR1->ReplaceDieFieldSet($die,"PnPBin", 0);
				next;
			}
			elsif($BinStat == -2)  # No_Flux_Bin
			{
				$RejParetoCounts{"numNo_Flux_Bin"}++;
				#$numMavGood--;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Flux_Bin");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Flux_Bin"});
				next;
			}
			elsif($BinStat == -1 || $BinStat == -3)  # No_Color_Bin and unknown bin
			{
				$RejParetoCounts{"numNo_Color_Bin"}++;
				#$numMavGood--;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Color_Bin");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Color_Bin"});
				next;
			}
			else
			{    # don't count it bad or good, EosGood should always equal Shipping Qty
				$RejParetoCounts{"numNo_RejCat"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_RejCat");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_RejCat"});
				#print LOG "Reject not classified for $FullWFRpath, die $die, binstat $BinStat\n";
				#print     "Reject not classified for die $die, binstat $BinStat\n";
				next;
			}
		}

		elsif(($RadioPhoto =~ /^(LdomPHIe).*/i) && !($Color =~ /^(White).*/i) && $BinStat < 1 && $VISflag == 1 ) # LDom and PHIe case
		{                                 # Can do either 350 or 1000 mA
			if($PHIe < 2.0)
			{
				$RejParetoCounts{"numNoLight"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Light");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Light"});
				next;
			}
			if($Vr	> CheckLimits::GetUpperProdLimit("Vr"))
			{
				$RejParetoCounts{"numLow_Vr"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Vr");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Vr"});
				next;
			}
			if($Vr	< CheckLimits::GetLowerProdLimit("Vr"))
			{
				$RejParetoCounts{"numHigh_Vr"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Vr");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Vr"});
				next;
			}
			if($WFR1->DieFieldExists("Vr_10_uA"))
			{
				if($Vr_10_uA > CheckLimits::GetUpperProdLimit("Vr_10_uA"))
				{
					$RejParetoCounts{"numLow_Vr_10uA"}++;
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Vr_10uA");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Vr_10uA"});
					next;
				}
				if($Vr_10_uA < CheckLimits::GetLowerProdLimit("Vr_10_uA"))
				{
					$RejParetoCounts{"numHigh_Vr_10uA"}++;
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Vr_10uA");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Vr_10uA"});
					next;
				}
			}
			if($VfLow < CheckLimits::GetLowerProdLimit("VfLow"))
			{
				$RejParetoCounts{"numLow_VfLow"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_VfLow");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_VfLow"});
				next;
			}
			if($VfLow > CheckLimits::GetUpperProdLimit("VfLow"))
			{
				$RejParetoCounts{"numHigh_VfLow"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_VfLow");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_VfLow"});
				next;
			}
			if($WFR1->DieFieldExists("$Vf_x_uA_name")) # in case WFR*.blu doesn't have Vf_x_uA
			{
				if($Vf_x_uA_value < CheckLimits::GetLowerProdLimit("$Vf_x_uA_name"))
				{
					$RejParetoCounts{"numLow_Vf_x_uA"}++;  # gets its own category
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_$Vf_x_uA_name");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_$Vf_x_uA_name"});
					next;
				}
			}
			if($WFR1->DieFieldExists("$Vf_x_uA_name")) # in case WFR*.blu doesn't have Vf_x_uA
			{
				if($Vf_x_uA_value > CheckLimits::GetUpperProdLimit("$Vf_x_uA_name"))
				{
					$RejParetoCounts{"numHigh_Vf_x_uA"}++;  # gets its own category
					$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_$Vf_x_uA_name");
					$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_$Vf_x_uA_name"});
					next;
				}
			}
			if($Vf >  CheckLimits::GetUpperProdLimit("Vf2"))
			{
				$RejParetoCounts{"numHigh_Vf"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Vf");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Vf"});
				next;
			}
			if($Vf < CheckLimits::GetLowerProdLimit("Vf2"))
			{
				$RejParetoCounts{"numLow_Vf"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Vf");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Vf"});
				next;
			}
			if($LambdaD	<  CheckLimits::GetLowerProdLimit("LambdaD"))
			{
				$RejParetoCounts{"numLow_WL"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_WL");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_WL"});
				next;
			}
			if($LambdaD >  CheckLimits::GetUpperProdLimit("LambdaD"))
			{
				$RejParetoCounts{"numHigh_WL"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_WL");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_WL"});
				next;
			}
			if($PHIe < CheckLimits::GetLowerProdLimit("PHIe"))  # cleanup of limits switched from Ie to PHIe
			{
				$RejParetoCounts{"numLow_Iv"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Low_Iv");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Low_Iv"});
				next;
			}
			if($PHIe > CheckLimits::GetUpperProdLimit("PHIe"))  # cleanup of limits switched from Ie to PHIe
			{
				$RejParetoCounts{"numHigh_Iv"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_High_Iv");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_High_Iv"});
				next;
			}
			#if($BinStat < 0)
			#{
			#	$RejParetoCounts{"numNo_Color_Bin"}++;
			#	$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Color_Bin");
			#	$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Color_Bin"});
			#	next;
			#}
			if($BinStat == -5)  # No_Vf_Bin
			{
				$RejParetoCounts{"numNo_Vf_Bin"}++;
				#$numMavGood--;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Vf_Bin");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Vf_Bin"});
				$WFR1->ReplaceDieFieldSet($die,"PnPBin", 0);
				next;
			}
			elsif($BinStat == -2)  # No_Flux_Bin
			{
				$RejParetoCounts{"numNo_Flux_Bin"}++;
				#$numMavGood--;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Flux_Bin");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Flux_Bin"});
				next;
			}
			elsif($BinStat == -1 || $BinStat == -3)  # No_Color_Bin and unknown bin
			{
				$RejParetoCounts{"numNo_Color_Bin"}++;
				#$numMavGood--;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_Color_Bin");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_Color_Bin"});
				next;
			}
			else
			{    # don't count it bad or good, EosGood should always equal Shipping Qty
				$RejParetoCounts{"numNo_RejCat"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_No_RejCat");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_No_RejCat"});
				#print LOG "Reject not classified for $FullWFRpath, die $die, binstat $BinStat\n";
				#print     "Reject not classified for die $die, binstat $BinStat\n";
				next;
			}
		}
		# Only total parts that are good, i.e. $BinStat == 1 and VISflag == 1
		if($BinStat == 1 && !$VISready)
		{
			$numMavGood++;
		}
		elsif($BinStat == 1 && $VISready && $VISflag == 1)
		{
			$numMavGood++;
		}
		elsif( $VISready && !$VISflag)  # VISrejects not counted in MavGood Yield
		{
			$RejParetoCounts{"numVISrej"}++;
			
			if($BinStat < 1)
			{
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Test_VISrej");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Test_VISrej"});
			}
			 elsif($VISflag == 2)
			{
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Burn_In");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Burn_In"});
			}
			else
			{
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_VISrej");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_VISrej"});
			}
		}
		elsif( $VISready && $VISflag !=1)  # VISrejects not counted in MavGood Yield
		{
			#$RejParetoCounts{"numVISrej"}++;
			
			#if($BinStat < 1)
			#{
			#	$WFR1->ReplaceDieField($die,"PartID", "FAIL_Test_VISrej");
			#	$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Test_VISrej"});
			#}
			if($VISflag == 2)
			{
				$RejParetoCounts{"numBurn_In"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_Burn_In");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_Burn_In"});
			}
			elsif($VISflag == 3)
			{
				$RejParetoCounts{"numOVM"}++;
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_OTHERS");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_OTHERS"});
			}
			else
			{
				$WFR1->ReplaceDieField($die,"PartID", "FAIL_VISrej");
				$WFR1->ReplaceDieField($die,"BinNum", $RejBinName2BinNumber{"FAIL_VISrej"});
			}	
		}
	
	} # end for die records

	# Build 2 lines of Maverick summary to be appended to WFS report
	# IMPORTANT: each format/limit change to this routine should bump the EosLabels_v# and EosData_v# in next 2 lines
	my $MavSumLabels = "\n\nEosLabels_v5\tLotID\tWaferID\tTestDate\tTestedDie\tShipQty\t";
	$MavSumLabels .= "EosGood\tEosGoodYld%\tNo_Light\tLow_Vr\tLow_VfLow\t";
	$MavSumLabels .= "High_Vf\tLow_Vf\tWrong_Pump\tThick_Phosphor\t";
	$MavSumLabels .= "Thin_Phosphor\tNo_Phosphor\tLow_Iv\tYellowTint\tPinkTint\tVersion\t";
	# FIXME: HighCCT was moved from the position after ThickPhosphor to maintain compatibility w/ version 3
	$MavSumLabels .= "High_CCT\tMap5th_Vf\tMap95th_Vf\tMapMean_Vf\tMapStdev_Vf\t";
	$MavSumLabels .= "Map5th_VfLow\tMap95th_VfLow\tMapMean_VfLow\tMapStdev_VfLow\t";
	$MavSumLabels .= "Map5th_Vr\tMap95th_Vr\tMapMean_Vr\tMapStdev_Vr\t";
	$MavSumLabels .= "Map5th_Iv\tMap95th_Iv\tMapMean_Iv\tMapStdev_Iv\t";
	$MavSumLabels .= "Map5th_CCT\tMap95th_CCT\tMapMean_CCT\tMapStdev_CCT\t";
	$MavSumLabels .= "Map5th_uprime\tMap95th_uprime\tMapMean_uprime\tMapStdev_uprime\t";
	$MavSumLabels .= "Map5th_vprime\tMap95th_vprime\tMapMean_vprime\tMapStdev_vprime\t";
	$MavSumLabels .= "Map5th_FR1e\tMap95th_FR1e\tMapMean_FR1e\tMapStdev_FR1e\t";
	$MavSumLabels .= "Func5th_uprime\tFunc95th_uprime\tFuncMean_uprime\tFuncStdev_uprime\t";
	$MavSumLabels .= "Func5th_vprime\tFunc95th_vprime\tFuncMean_vprime\tFuncStdev_vprime\t";
	$MavSumLabels .= "Func5th_CCT\tFunc95th_CCT\tFuncMean_CCT\tFuncStdev_CCT\tFuncDieCount\t";
	$MavSumLabels .= "TesterID\tTestSpec\t";
	$MavSumLabels .= "LP430\tLP435\tLP440\tLP445\tLP450\tLP455\tLP460\tLP465\tVIS_Failed\tVf_x_uA_Failed\t";
	$MavSumLabels .= "NoColorBin\tLow_CRI\tHigh_VfLow\tHigh_Vr\tHigh_WL\tLow_WL\tHigh_Iv\tBurn_In\tL1Part\tLow_Vr_10uA\tHigh_Vr_10uA\tLow_DVf_100uA\tHigh_DVf_100uA\tNoFluxBin\tNoVfBin\tOVM\tLow_VfPost01\tHigh_VfPost01\tLow_PHIv_Outlier\tHigh_Vf2_Outlier\tLow_Vf_10_uA_Outlier\n";
	#$MavSumLabels .= "Low_Vf2_Outlier\tHigh_Vf2_Outlier\n";
	my $MavSumData = "EosData_v5\t";
	my $TestDate = $WFR1->GetHeaderField("Tested","Tested");
	my $TesterID = GetTesterName();
	my $TestSpec = $WFR1->GetHeaderField("ReprocSpec","Test Spec");
	my $numTestedDie = $YieldBasis;

	my $MavYield = 0;
	if( $numTestedDie > $RejParetoCounts{"numVISrej"})
	{
	   $MavYield = ($numMavGood/($numTestedDie - $RejParetoCounts{"numVISrej"}))*100;  # max tested minus VISrej is basis for this yield calculation
	}
	
	# Compute selected parametric statistics
	my $Map5th_Vf = percentile(\@MAP_Vf, 5);
	my $Map95th_Vf = percentile(\@MAP_Vf, 95);
	my %MapStats_Vf =  StatisticsLite::statshash(@MAP_Vf);
	my $MapMean_Vf = $MapStats_Vf{"mean"};
	my $MapStdev_Vf = $MapStats_Vf{"stddev"};

	my $Map5th_VfLow = percentile(\@MAP_VfLow, 5);
	my $Map95th_VfLow = percentile(\@MAP_VfLow, 95);
	my %MapStats_VfLow =  StatisticsLite::statshash(@MAP_VfLow);
	my $MapMean_VfLow = $MapStats_VfLow{"mean"};
	my $MapStdev_VfLow = $MapStats_VfLow{"stddev"};

	my $Map5th_Vr = percentile(\@MAP_Vr, 5);
	my $Map95th_Vr = percentile(\@MAP_Vr, 95);
	my %MapStats_Vr =  StatisticsLite::statshash(@MAP_Vr);
	my $MapMean_Vr = $MapStats_Vr{"mean"};
	my $MapStdev_Vr = $MapStats_Vr{"stddev"};

	my $Map5th_Iv = percentile(\@MAP_Iv, 5);
	my $Map95th_Iv = percentile(\@MAP_Iv, 95);
	my %MapStats_Iv =  StatisticsLite::statshash(@MAP_Iv);
	my $MapMean_Iv = $MapStats_Iv{"mean"};
	my $MapStdev_Iv = $MapStats_Iv{"stddev"};

	my( $Map5th_CCT,$Map95th_CCT,%MapStats_CCT,$MapMean_CCT,$MapStdev_CCT);
	my( $Map5th_uprime,$Map95th_uprime,%MapStats_uprime,$MapMean_uprime,$MapStdev_uprime);
	my( $Map5th_vprime,$Map95th_vprime,%MapStats_vprime,$MapMean_vprime,$MapStdev_vprime);
	my( $Map5th_FR1e,$Map95th_FR1e,%MapStats_FR1e,$MapMean_FR1e,$MapStdev_FR1e);
	my( $Func5th_uprime,$Func95th_uprime,%FuncStats_uprime,$FuncMean_uprime,$FuncStdev_uprime);
	my( $Func5th_vprime,$Func95th_vprime,%FuncStats_vprime,$FuncMean_vprime,$FuncStdev_vprime);
	my( $Func5th_CCT,$Func95th_CCT,%FuncStats_CCT,$FuncMean_CCT,$FuncStdev_CCT);

	if($Color =~ /^(White).*/i)  # white only
	{
		$Map5th_CCT = percentile(\@MAP_CCT, 5);
		$Map95th_CCT = percentile(\@MAP_CCT, 95);
		%MapStats_CCT =  StatisticsLite::statshash(@MAP_CCT);
		$MapMean_CCT = $MapStats_CCT{"mean"};
		$MapStdev_CCT = $MapStats_CCT{"stddev"};

		$Map5th_uprime = percentile(\@MAP_uprime, 5);
		$Map95th_uprime = percentile(\@MAP_uprime, 95);
		%MapStats_uprime =  StatisticsLite::statshash(@MAP_uprime);
		$MapMean_uprime = $MapStats_uprime{"mean"};
		$MapStdev_uprime = $MapStats_uprime{"stddev"};

		$Map5th_vprime = percentile(\@MAP_vprime, 5);
		$Map95th_vprime = percentile(\@MAP_vprime, 95);
		%MapStats_vprime =  StatisticsLite::statshash(@MAP_vprime);
		$MapMean_vprime = $MapStats_vprime{"mean"};
		$MapStdev_vprime = $MapStats_vprime{"stddev"};

		$Map5th_FR1e = percentile(\@MAP_FR1e, 5);
		$Map95th_FR1e = percentile(\@MAP_FR1e, 95);
		%MapStats_FR1e =  StatisticsLite::statshash(@MAP_FR1e);
		$MapMean_FR1e = $MapStats_FR1e{"mean"};
		$MapStdev_FR1e = $MapStats_FR1e{"stddev"};

		$Func5th_uprime = percentile(\@FUNC_uprime, 5);
		$Func95th_uprime = percentile(\@FUNC_uprime, 95);
		%FuncStats_uprime =  StatisticsLite::statshash(@FUNC_uprime);
		$FuncMean_uprime = $FuncStats_uprime{"mean"};
		$FuncStdev_uprime = $FuncStats_uprime{"stddev"};

		$Func5th_vprime = percentile(\@FUNC_vprime, 5);
		$Func95th_vprime = percentile(\@FUNC_vprime, 95);
		%FuncStats_vprime =  StatisticsLite::statshash(@FUNC_vprime);
		$FuncMean_vprime = $FuncStats_vprime{"mean"};
		$FuncStdev_vprime = $FuncStats_vprime{"stddev"};

		$Func5th_CCT = percentile(\@FUNC_CCT, 5);
		$Func95th_CCT = percentile(\@FUNC_CCT, 95);
		%FuncStats_CCT =  StatisticsLite::statshash(@FUNC_CCT);
		$FuncMean_CCT = $FuncStats_CCT{"mean"};
		$FuncStdev_CCT = $FuncStats_CCT{"stddev"};
	}
	else   # non-white
	{
		$Map5th_CCT = 0;
		$Map95th_CCT = 0;
		$MapMean_CCT = 0;
		$MapStdev_CCT = 0;

		$Map5th_uprime = 0;
		$Map95th_uprime = 0;
		$MapMean_uprime = 0;
		$MapStdev_uprime = 0;

		$Map5th_vprime = 0;
		$Map95th_vprime = 0;
		$MapMean_vprime = 0;
		$MapStdev_vprime = 0;

		$Map5th_FR1e = 0;
		$Map95th_FR1e = 0;
		$MapMean_FR1e = 0;
		$MapStdev_FR1e = 0;

		$Func5th_uprime = 0;
		$Func95th_uprime = 0;
		$FuncMean_uprime = 0;
		$FuncStdev_uprime = 0;

		$Func5th_vprime = 0;
		$Func95th_vprime = 0;
		$FuncMean_vprime = 0;
		$FuncStdev_vprime = 0;

		$Func5th_CCT = 0;
		$Func95th_CCT = 0;
		$FuncMean_CCT = 0;
		$FuncStdev_CCT = 0;
	}
	$MavSumData .= "$RawLotName\t$WaferID\t$TestDate\t$numTestedDie\t";
	$MavSumData .= "$TotalGoodDie\t$numMavGood\t$MavYield\t";
	$MavSumData .= $RejParetoCounts{"numNoLight"}."\t";
	$MavSumData .= $RejParetoCounts{"numLow_Vr"}."\t";
	$MavSumData .= $RejParetoCounts{"numLow_VfLow"}."\t";
	$MavSumData .= $RejParetoCounts{"numHigh_Vf"}."\t";
	$MavSumData .= $RejParetoCounts{"numLow_Vf"}."\t";
	$MavSumData .= $RejParetoCounts{"numWrongPump"}."\t";
	$MavSumData .= $RejParetoCounts{"numThickPhosphor"}."\t";
	$MavSumData .= $RejParetoCounts{"numThinPhosphor"}."\t";
	$MavSumData .= $RejParetoCounts{"numNoPhosphor"}."\t";
	$MavSumData .= $RejParetoCounts{"numLow_Iv"}."\t";
	$MavSumData .= $RejParetoCounts{"numYellowTint"}."\t";
	$MavSumData .= $RejParetoCounts{"numPinkTint"}."\t";
	$MavSumData .= "v5\t";   #Record Format Version field, introduced w/ v4

	# FIXME: HighCCT was moved from the position after ThickPhosphor to maintain compatibility w/ version 3
	$MavSumData .= $RejParetoCounts{"numHighCCT"}."\t";

	$MavSumData .= $Map5th_Vf."\t";
	$MavSumData .= $Map95th_Vf."\t";
	$MavSumData .= $MapMean_Vf."\t";
	$MavSumData .= $MapStdev_Vf."\t";

	$MavSumData .= $Map5th_VfLow."\t";
	$MavSumData .= $Map95th_VfLow."\t";
	$MavSumData .= $MapMean_VfLow."\t";
	$MavSumData .= $MapStdev_VfLow."\t";

	$MavSumData .= $Map5th_Vr."\t";
	$MavSumData .= $Map95th_Vr."\t";
	$MavSumData .= $MapMean_Vr."\t";
	$MavSumData .= $MapStdev_Vr."\t";

	$MavSumData .= $Map5th_Iv."\t";
	$MavSumData .= $Map95th_Iv."\t";
	$MavSumData .= $MapMean_Iv."\t";
	$MavSumData .= $MapStdev_Iv."\t";

	$MavSumData .= $Map5th_CCT."\t";
	$MavSumData .= $Map95th_CCT."\t";
	$MavSumData .= $MapMean_CCT."\t";
	$MavSumData .= $MapStdev_CCT."\t";

	$MavSumData .= $Map5th_uprime."\t";
	$MavSumData .= $Map95th_uprime."\t";
	$MavSumData .= $MapMean_uprime."\t";
	$MavSumData .= $MapStdev_uprime."\t";

	$MavSumData .= $Map5th_vprime."\t";
	$MavSumData .= $Map95th_vprime."\t";
	$MavSumData .= $MapMean_vprime."\t";
	$MavSumData .= $MapStdev_vprime."\t";

	$MavSumData .= $Map5th_FR1e."\t";
	$MavSumData .= $Map95th_FR1e."\t";
	$MavSumData .= $MapMean_FR1e."\t";
	$MavSumData .= $MapStdev_FR1e."\t";

	$MavSumData .= $Func5th_uprime."\t";
	$MavSumData .= $Func95th_uprime."\t";
	$MavSumData .= $FuncMean_uprime."\t";
	$MavSumData .= $FuncStdev_uprime."\t";

	$MavSumData .= $Func5th_vprime."\t";
	$MavSumData .= $Func95th_vprime."\t";
	$MavSumData .= $FuncMean_vprime."\t";
	$MavSumData .= $FuncStdev_vprime."\t";

	$MavSumData .= $Func5th_CCT."\t";
	$MavSumData .= $Func95th_CCT."\t";
	$MavSumData .= $FuncMean_CCT."\t";
	$MavSumData .= $FuncStdev_CCT."\t";
	$MavSumData .= $FUNC_DieCount."\t";
	$MavSumData .= $TesterID."\t";
	$MavSumData .= $TestSpec."\t";
	$MavSumData .= $Lp1Bins{'LP430'}."\t";
	$MavSumData .= $Lp1Bins{'LP435'}."\t";
	$MavSumData .= $Lp1Bins{'LP440'}."\t";
	$MavSumData .= $Lp1Bins{'LP445'}."\t";
	$MavSumData .= $Lp1Bins{'LP450'}."\t";
	$MavSumData .= $Lp1Bins{'LP455'}."\t";
	$MavSumData .= $Lp1Bins{'LP460'}."\t";
	$MavSumData .= $Lp1Bins{'LP465'}."\t";
	$MavSumData .= $RejParetoCounts{"numVISrej"}."\t";
	if($WFR1->DieFieldExists("$Vf_x_uA_name"))
	{
		#$MavSumData .= $RejParetoCounts{"numLow_Vf_x_uA"}."\t";
		$MavSumData .= ($RejParetoCounts{"numLow_Vf_x_uA"}) + ($RejParetoCounts{"numHigh_Vf_x_uA"})."\t";
	}
	else
	{
		$MavSumData .= "0\t";
	}
	$MavSumData .= $RejParetoCounts{"numNo_Color_Bin"}."\t";
	if($WFR1->DieFieldExists("CRI"))
	{
		$MavSumData .= $RejParetoCounts{"numLow_CRI"}."\t";
	}
	else
	{
		$MavSumData .= "0\t";
	}
	$MavSumData .= $RejParetoCounts{"numHigh_VfLow"}."\t";
	$MavSumData .= $RejParetoCounts{"numHigh_Vr"}."\t";
	$MavSumData .= $RejParetoCounts{"numHigh_WL"}."\t";
	$MavSumData .= $RejParetoCounts{"numLow_WL"}."\t";
	$MavSumData .= $RejParetoCounts{"numHigh_Iv"}."\t";
	$MavSumData .= $RejParetoCounts{"numBurn_In"}."\t";
	my $L1Part = TesterParts2::GetL1Part($TesterType);
	$MavSumData .= "$L1Part\t";
	$MavSumData .= $RejParetoCounts{"numLow_Vr_10uA"}."\t";
	$MavSumData .= $RejParetoCounts{"numHigh_Vr_10uA"}."\t";
	$MavSumData .= $RejParetoCounts{"numLow_DVf_100uA"}."\t";
	$MavSumData .= $RejParetoCounts{"numHigh_DVf_100uA"}."\t";
	$MavSumData .= $RejParetoCounts{"numNo_Flux_Bin"}."\t";
	$MavSumData .= $RejParetoCounts{"numNo_Vf_Bin"}."\t";
	$MavSumData .= $RejParetoCounts{"numOVM"}."\t";
	$MavSumData .= $RejParetoCounts{"numLow_VfPost01"}."\t";
	$MavSumData .= $RejParetoCounts{"numHigh_VfPost01"}."\t";
	$MavSumData .= $RejParetoCounts{"numLow_PHIv_Outlier"}."\t";
	#$MavSumData .= $RejParetoCounts{"numLow_Vf2_Outlier"}."\t";
	$MavSumData .= $RejParetoCounts{"numHigh_Vf2_Outlier"}."\t";
	$MavSumData .= $RejParetoCounts{"numLow_Vf_10_uA_Outlier"}."\t";
	#$MavSumData .= $PHIvOutlierCounts."\t";
	
	$MavSumData .= "\n";
	# no place in the summary files for this category yet.
	#print "Has ".$RejParetoCounts{"numNo_Color_Bin"}." Color\|Flux\|Vf Bin rejects\n";
	print "Has ".$RejParetoCounts{"numNo_Color_Bin"}." No_Color_Bin rejects\n";
	print "Has ".$RejParetoCounts{"numNo_Flux_Bin"}." No_Flux_Bin rejects\n";
	print "Has ".$RejParetoCounts{"numNo_Vf_Bin"}." No_Vf_Bin rejects\n";
	print "Has ".$RejParetoCounts{"numNo_RejCat"}." No_Rej_Cat rejects\n";
	return $MavSumLabels.$MavSumData;
}

sub WFRreport($) # ($reportdir)
{
	my $wfrfilepath = "$_[0]/WFR$WaferID.blu";
	print "WFR Rpt: $wfrfilepath\n";
	Win32::File::SetAttributes($wfrfilepath, NORMAL) if -e $wfrfilepath;
	open(WFROUT,">$wfrfilepath") || die "Can't open $wfrfilepath for writing!\n";
	# Print header section and make any adjustments to the header data
	print WFROUT $WFR1->GetHeaderLabels(); # just the header field names
	$WFR1->ReplaceHeaderField("Good Die", $TotalGoodDie, "");
    my $testedDate = $WFR1->GetHeaderField("Tested","");
	# $WFR1->ReplaceHeaderField("RptCreated", $testedDate, "Created"); # done to create invariant file contents for same SW/parts
	$WFR1->ReplaceHeaderField("RptCreated", ReportDateTime(), "Created");

	# get rid of the huge floating numbers for uninitialized data
	if( $WFR1->GetHeaderField("VfLowLimit","") < -20.0 ) { ReplaceHeaderField("VfLowLimit",'1.5',"");}
	if( $WFR1->GetHeaderField("VfLowPostLimit","") < -20.0 ) { ReplaceHeaderField("VfLowPostLimit",'1.5',"");}
	print WFROUT $WFR1->GetHeaderData(); # now print the adjusted header data
	
	# print die fields header
	print WFROUT $WFR1->GetDieColumnLabels();

	# Print each raw record, assuming we have already updated any new field values
	for( my $dn=0; $dn < $numdierecs; $dn++)
	{
		print WFROUT $WFR1->GetDieData($dn);
	}	
	close WFROUT;
}

sub PnPreport($) # ($reportdir)
{
	# Print the GANBIN style report for the PnP system using $LotID$WaferID.txt as the file name
	# remember: the align die section is product-specific
	my $pnpfilepath = "$_[0]/DPM";
    my $barewafid = $WaferID;
    $barewafid =~ s/-$Iforce$//gi;
    $barewafid =~ s/-$VISpoststep$//gi;  # if it is there
	$barewafid =~ s/-Tj[0-9]{2,3}$//gi;  # if it is there
    $pnpfilepath .= "$barewafid\.txt";
	print "PnP Rpt: $pnpfilepath\n";
	Win32::File::SetAttributes($pnpfilepath, NORMAL) if -e $pnpfilepath;
	open(PNP,">$pnpfilepath") || die "Can't open $pnpfilepath for writing!\n";

	print PNP "LOT NO\t: GANBIN\n";
	print PNP "WAFER NO\t: 3\n";
	print PNP "TESTER NO\t: WP1\n";
	print PNP "DATE/TIME\t: 8214091590\n";
	print PNP "OPERATOR\t: X01\n";

	if(ProductStructure::GetNumberAlignDie() > 0)
	{	
		my $RefDieX = $Align2AlignRC{"A-1"}[1];  # assumes there is always at least AlignDie #1
		my $RefDieY = $Align2AlignRC{"A-1"}[0];
		print PNP "REF POINT\t: $RefDieX,\-$RefDieY\n\n"; # need to negate the row number for QISM
	}
	else
	{
		print PNP "REF POINT\t: 0,0\n\n"; # dummy value
		print "No align die available in $PartLink Product Structure for PnP report!\n";
	}
	print PNP "DIE\tX\tY\tBIN\n";
	my $maxAlignNum = 0;
	if(ProductStructure::GetNumberAlignDie() > 0)
	{	
        my $alignNum = 0;
		# First add the align die, with a bin of -2
		foreach my $alignkey (sort keys %Align2AlignRC)
		{
			my $alignX = $Align2AlignRC{$alignkey}[1];
			my $alignY = $Align2AlignRC{$alignkey}[0];
			my @alignList = split("\-",$alignkey);
			$alignNum += 1; # so we get an ascending align number, may not always match the A-# in the key
			print PNP "$alignNum\t$alignX\t\-$alignY\t-2\n"; # need to negate the row number for QISM
			# compute the highest alignNum used so we can start the pnpDie at the right number
			if($alignNum > $maxAlignNum)
			{
				$maxAlignNum = $alignNum;
			}
		}
	}
	%PnPBinCounts = (); # reset the counters
    %PnPPartIDs = ();  # clear the lookup table
	# Now add all the tested die
	for(my $ax=0; $ax < $numArrayLeds; $ax++)
	{
		IsArrayComplete($ax) || next;
		@dieset = ProductStructure::GetDieSet4Array($ax);
		my $pnpDie = $ax + $maxAlignNum + 1;
		my $pnpX = $WFR1->GetDieField($dieset[0],"aCol");
		my $pnpY = -$WFR1->GetDieField($dieset[0],"aRow");  # row number is negated for PnP system
		my $pnpBin = $WFR1->GetDieField($dieset[0],"PnPBin");
		my $pnpPartID = $WFR1->GetDieField($dieset[0],"PartID");
		$PnPBinCounts{$pnpBin}++;   # still counting engineering bins for summary purpose
        $PnPPartIDs{$pnpBin} = $pnpPartID;
		print PNP "$pnpDie\t$pnpX\t$pnpY\t$pnpBin\n";
	}
	close PNP;
}

sub PnPSummary($) # ($reportdir)
{
	# Summarize PnP bin counts for this wafer.
	my $pnpsumfilepath = "$_[0]/DPS$RawLotName-$WaferID.txt";
	print "PnPSum Rpt: $pnpsumfilepath\n";
	Win32::File::SetAttributes($pnpsumfilepath, NORMAL) if -e $pnpsumfilepath;
	open(PNPSUM,">$pnpsumfilepath") || die "Can't open $pnpsumfilepath for writing!\n";
	print PNPSUM "\tTileID\tIforce\tTotalDie\tGoodDie\tL1Part\tL0Part\tBinCat\tPnPBin\tBinCount\n";
	my $TotalDie = 0;
	my $GoodDie = 0;
	foreach my $pnpcountkey ( keys %PnPBinCounts )
	{
		my $pnpcount = $PnPBinCounts{$pnpcountkey};
		if($pnpcountkey == 0 )
		{
			$TotalDie += $pnpcount;
		}
		else
		{
			$TotalDie += $pnpcount;
			$GoodDie += $pnpcount;
		}
	}
    my $TileID = $WaferID;
    $TileID =~ s/-$Iforce$//;
    $TileID =~ s/-$VISpoststep$//gi; # chop off the timepoint from the WaferID
	$TileID =~ s/-Tj[0-9]{2,3}$//gi;  # if it is there
	foreach my $pnpcountkey ( sort keys %PnPBinCounts )
	{
		my $pnpcount = $PnPBinCounts{$pnpcountkey};
        my $pnpBinCat = $PnPPartIDs{$pnpcountkey};
        if($pnpcountkey > 0)
        {
            $pnpBinCat =~ s/^$L0Part//;  # remove the basepart number part
            $pnpBinCat =~ s/^\-//;  # remove any hyphens
        }
#	elsif($pnpcountkey == 777)  #Maverick
#        {
#            $pnpBinCat = "FAIL";  
#        }
        else
        {
            $pnpBinCat = "FAIL";
        }
        print PNPSUM "$RawLotName\t$TileID\t$Iforce\t$TotalDie\t$GoodDie\t";
		print PNPSUM "$L1Part\t$L0Part\t$pnpBinCat\t$pnpcountkey\t$pnpcount\n";
	}
	close PNPSUM;
}

sub ReportDateTime()
{
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
	$mon +=1; # 0 based
	$year += 1900;
	my $reportdatetime = "$mon/$mday/$year $hour:$min:$sec";
	return $reportdatetime;
}

sub GetTesterName()
{
	my $ProberID = $WFR1->GetHeaderField("Prober","Prober");
	return uc($ProberID);
}

sub percentile # ($ArrayRef, $PercentileDesired)
{
    my ($array, $percentile) = @_;
    # note: this isn't very efficient if you need to do a bunch of percentiles
    # on the same array of data. Just copy/modify next 3 lines
    #  into where you need percentiles, and sort once only.
    my @sorted = sort {$a <=> $b} @$array;
    my $index = int((@sorted * $percentile)/100);
    return $sorted[$index];
}

sub WFZreport($) # ($reportdir)
{   # this routine handles just the file I/O
	my $wfzfilepath = "$_[0]/WFZ$WaferID.blu";
	print "WFZ Rpt: $wfzfilepath\n";
	Win32::File::SetAttributes($wfzfilepath, NORMAL) if -e $wfzfilepath;
	open(WFZOUT, ">$wfzfilepath") || die "Can't open $wfzfilepath for writing!\n";
	print WFZOUT $WFZRpt;  # Which was created in WFZgenerator()
	close WFZOUT;
}

sub WFZgenerator() # ()
{
    # FIXME: INCLUDES SABER VISUAL reject devices
    # Initialize $Report, acquire common data (LotID, WaferID, TestDate, WafYield%)
    $WFZRpt = (); # re-init this global report
    my $pLotID = $RawLotName;
    my $pWafID = $WaferID;
	my @TestDateTime = split(" ",$WFR1->GetHeaderField("Tested","Tested"));
    my $pTestDate = $TestDateTime[0];   # get just the day part, ignore time
    my $pWafYieldPct = $TotalYield;
    # print label line (with first label field blank)
    $WFZRpt = "\tWaferID\tTestDate\tWafYieldPct\tParam\tCatRejPct\tMean\tSdev\tCount\t";
    $WFZRpt .= "Min\t5th\t10th\t25th\t30th\t50th\t70th\t75th\t90th\t95th\tMax\n";
    # Iterate through the diefields looking for parameters
    my @DieFieldNames = $WFR1->GetDieFieldNames();
    foreach my $param ( @DieFieldNames )
    {
        # Verify that the diefield is a (wanted)test parameter. Init param structs.
        my @ParamVals = ();
        if(CheckLimits::IsATest($param))
        {
            my $pCatRejCnt=0;
            # If a parameter, iterate through all die records.
        	for( $die=0; $die < $numdierecs; $die++)
            {
                # Get parameter value, push into parameter accumulation array.
                my $pval = $WFR1->GetDieField($die, $param);
                if($param =~ /^Lambda/i && ($pval < 400 || $pval > 580))
                {
                    #print "WFZ: Skipping $param: $pval for die $die\n";
                }
                elsif($param =~ /^FWHM/i && $pval > 150)
                {
                    #print "WFZ: Skipping $param: $pval for die $die\n";
                }
                elsif( $pval =~ /NaN/)
                {
                    #print "WFZ: Skipping $param: $pval for die $die\n";
                }
                else
                {
                    push(@ParamVals, $pval);
                }
                if((CheckLimits::ShowDiePassTname($die,$param)==0) &&
                    CheckLimits::TestIsActive($param))
                {
                    $pCatRejCnt+= 1; #if available, unordered, use Pass cat flags
                }
            }
            my $pCatRejPct = ($pCatRejCnt/$YieldBasis)*100;
            # Compute untrimmed parameter statistics (mean,stdev,count,min,
            #     5th,10th,25th,30th,50th,70th,75th,90th,95th percentiles, max).
            my %pStatsHash =  StatisticsLite::statshash(@ParamVals);
            my $pMean  = $pStatsHash{"mean"};
            my $pStdev = $pStatsHash{"stddev"};
            my $pMax   = $pStatsHash{"max"};
            my $pMin   = $pStatsHash{"min"};
            my $pCount = @ParamVals;
            my @pSorted =  sort {$a <=> $b} @ParamVals;  # ascending numeric order
            my $p5th =  $pSorted[int((@pSorted *  5.0)/100)];
            my $p10th = $pSorted[int((@pSorted * 10.0)/100)];
            my $p25th = $pSorted[int((@pSorted * 25.0)/100)];
            my $p30th = $pSorted[int((@pSorted * 30.0)/100)];
            my $p50th = $pSorted[int((@pSorted * 50.0)/100)];  # median
            my $p70th = $pSorted[int((@pSorted * 70.0)/100)];
            my $p75th = $pSorted[int((@pSorted * 75.0)/100)];
            my $p90th = $pSorted[int((@pSorted * 90.0)/100)];
            my $p95th = $pSorted[int((@pSorted * 95.0)/100)];
            # Concatenate line of report for this parameter.
            $WFZRpt .= "$pLotID\t$pWafID\t$pTestDate\t$pWafYieldPct\t$param\t$pCatRejPct\t";
            $WFZRpt .= "$pMean\t$pStdev\t$pCount\t$pMin\t$p5th\t$p10th\t$p25th\t";
            $WFZRpt .= "$p30th\t$p50th\t$p70th\t$p75th\t$p90th\t$p95th\t$pMax\n";
        }
        # Repeat for next parameter.
    }
  	return;
}

sub TSMreport($) # ($reportdir)
{
	my $tsmfilepath = "$_[0]/TSM\_$RawLotName\_$WaferID.txt";
	print "TSM Rpt: $tsmfilepath\n";
    my $barewafid = $WaferID;
    $barewafid =~ s/-$Iforce$//gi;
    $barewafid =~ s/-$VISpoststep$//gi;  # if it is there
	$barewafid =~ s/-Tj[0-9]{2,3}$//gi;  # if it is there
    my $optionFilePath = "$_[0]/TSM\_$BinOption\_$RawLotName\_$barewafid.txt";
    
	Win32::File::SetAttributes($tsmfilepath, NORMAL) if -e $tsmfilepath;
	open(TSM,">$tsmfilepath") || die "Can't open $tsmfilepath for writing!\n";

    print TSM "Lot#\tTile#\tLamp#\tX\tY\tPossibleBasePart#\tPossibleBinCat\tOptionCodes\tIforce\tBinStructure\tLED\tPhosphor\tSelected\tPnPBin\n";

	%TsmBinCounts = (); # reset the counters
    %TsmPartIDs = ();  # clear the lookup table
    my $TileID = $WaferID;
    $TileID =~ s/-$Iforce$//gi; # chop off the drive condition from the WaferID
    $TileID =~ s/-$VISpoststep$//gi; # chop off the timepoint from the WaferID
	$TileID =~ s/-Tj[0-9]{2,3}$//gi;  # if it is there
    # next, pick the Binning Structure used

	# Now add all the tested die
	for(my $ax=0; $ax < $numArrayLeds; $ax++)
	{
		IsArrayComplete($ax) || next;
        my $tsmDie = $ax + 1;
		@dieset = ProductStructure::GetDieSet4Array($ax);
		my $tsmX = $WFR1->GetDieField($dieset[0],"aCol");
		my $tsmY = -$WFR1->GetDieField($dieset[0],"aRow");  # row number is negated for PnP system
		my $tsmBin = $WFR1->GetDieField($dieset[0],"PnPBin");
		my $tsmPartID = $WFR1->GetDieField($dieset[0],"PartID");
		$TsmBinCounts{$tsmBin}++;
        $TsmPartIDs{$tsmBin} = $tsmPartID;
        if($tsmBin > 0)
        {   # get just the bincat part
            $tsmPartID =~ s/^$L0Part//;  # remove the L0 base part number section, which includes the -1
            #$tsmPartID =~ s/^\-//;  # remove any additional hyphens
        }
	elsif ($tsmPartID eq "FAIL_Low_PHIv_Outlier")
	{
		$tsmPartID = "ORT";
	}
        else
        {
            $tsmPartID = "FAIL";
        }

   		print TSM "$RawLotName\t$TileID\t$tsmDie\t$tsmX\t$tsmY\t$L1Part\t$tsmPartID\t$OptionCodes\t$Iforce\t$BinStructure\t$LED\t$Phosphor\t0\t$tsmBin\n";
	}
	close TSM;
    
	Win32::File::SetAttributes($optionFilePath, NORMAL) if -e $optionFilePath;
    File::Copy::copy($tsmfilepath, $optionFilePath) || die "Can't copy $tsmfilepath to $optionFilePath\n";
    # same data, slightly different filename for use by Siew's database
	print "TSM Rpt: $optionFilePath\n";
    
}

sub TSSreport($) # ($reportdir)
{
	# Summarize TSM bin counts for this wafer.
	my $tssfilepath = "$_[0]/TSS\_$RawLotName\_$WaferID.txt";
	print "TSS Rpt: $tssfilepath\n";
	Win32::File::SetAttributes($tssfilepath, NORMAL) if -e $tssfilepath;
	open(TSS,">$tssfilepath") || die "Can't open $tssfilepath for writing!\n";
	print TSS "Lot#\tTile#\tBasePart#\tBinCat\tOptionCodes\tIforce\tBinStructure\tLED\tPhosphor\tQty\tPnPBin\n";

    my $TileID = $WaferID;
    $TileID =~ s/-$Iforce$//;
    $TileID =~ s/-$VISpoststep$//gi; # chop off the timepoint from the WaferID
	$TileID =~ s/-Tj[0-9]{2,3}$//gi;  # if it is there
    # next, pick the Binning Structure used

	foreach my $tsmcountkey ( sort keys %TsmBinCounts )
	{
		my $tsmcount = $TsmBinCounts{$tsmcountkey};
        my $tsmBinCat = $TsmPartIDs{$tsmcountkey};
        if($tsmcountkey > 0)
        {
            $tsmBinCat =~ s/^$L0Part//;  # remove the basepart number part
            $tsmBinCat =~ s/^\-//;  # remove any hyphens
        }
        else
        {
            $tsmBinCat = "FAIL";
        }
        print TSS "$RawLotName\t$TileID\t$L1Part\t$tsmBinCat\t$OptionCodes\t$Iforce\t$BinStructure\t$LED\t$Phosphor\t$tsmcount\t$tsmcountkey\n";
	}
	close TSS;
}

sub TRMreport($) # ($reportdir)
{
	# Print the TRM style report for the PnP system using TRM_ST_$WaferID.txt as the file name
	# remember: the align die section is product-specific
	my $trmfilepath = "$_[0]/TRM_ST_";
    my $barewafid = $WaferID;
    $barewafid =~ s/-$Iforce$//gi;
    $barewafid =~ s/-$VISpoststep$//gi;  # if it is there
	$barewafid =~ s/-Tj[0-9]{2,3}$//gi;  # if it is there
    $trmfilepath .= "$barewafid\.txt";
	print "TRM Rpt: $trmfilepath\n";
	Win32::File::SetAttributes($trmfilepath, NORMAL) if -e $trmfilepath;
	open(TRM,">$trmfilepath") || die "Can't open $trmfilepath for writing!\n";

	print TRM "WO NO\t: \n";
	print TRM "LOT NO\t: $RawLotName\n";
	print TRM "CARRIER NO\t: \n";
	print TRM "MACHINE NO\t: \n";
	print TRM "BIN NO\t: \n";
	print TRM "DIE QTY\t: \n";
	print TRM "DATE/TIME\t: \n";
	print TRM "OPERATOR\t: X01\n";

	if(ProductStructure::GetNumberAlignDie() > 0)
	{
		my $RefDieX = $Align2AlignRC{"A-1"}[1];  # assumes there is always at least AlignDie #1
		my $RefDieY = $Align2AlignRC{"A-1"}[0];
		print TRM "REF POINT\t: $RefDieX, $RefDieY\n\n"; # need to negate the row number for QISM
	}
	else
	{
		print TRM "REF POINT\t: 0,0\n\n"; # dummy value
		print "No align die available in $PartLink Product Structure for TRM report!\n";
	}
	print TRM "DIE\tX\tY\tTRN\tBIN\tBASEPART\tCATCODE\tOPTIONCODES\n";
	my $maxAlignNum = 0;
	if(ProductStructure::GetNumberAlignDie() > 0)
	{
        my $alignNum = 0;
		# First add the align die, with a bin of -2
		foreach my $alignkey (sort keys %Align2AlignRC)
		{
			my $alignX = $Align2AlignRC{$alignkey}[1];
			my $alignY = $Align2AlignRC{$alignkey}[0];
			my @alignList = split("\-",$alignkey);
			$alignNum += 1; # so we get an ascending align number, may not always match the A-# in the key
			print TRM "$alignNum\t$alignX\t\-$alignY\t-\t-2\n"; # need to negate the row number for QISM
			# compute the highest alignNum used so we can start the TRMDie at the right number
			if($alignNum > $maxAlignNum)
			{
				$maxAlignNum = $alignNum;
			}
		}
	}
	my %TrmBinCounts = (); # reset the counters
    my %TrmPartIDs = ();  # clear the lookup table
	# Now add all the tested die
	for(my $ax=0; $ax < $numArrayLeds; $ax++)
	{
		IsArrayComplete($ax) || next;
		@dieset = ProductStructure::GetDieSet4Array($ax);
		my $pnpDie = $ax + $maxAlignNum + 1;
		my $pnpX = $WFR1->GetDieField($dieset[0],"aCol");
		my $pnpY = -$WFR1->GetDieField($dieset[0],"aRow");  # row number is negated for PnP system
		my $pnpBin = $WFR1->GetDieField($dieset[0],"PnPBin");
		#print "pnp Bin : $pnpBin\n";

                my $trn = sprintf("$barewafid%04d", -$pnpY + 38*(45 - $pnpX));  # should calculate max row number, right now fixed for 4" Rebel=20
				
                #if ($L0Part =~ /^(F6N.*)\-2$/)
		#	{	                
		#		   $trn = sprintf("$barewafid%04d", -$pnpY + 38*(45 - $pnpX));  # should calculate max row number, right now fixed for 4" Rebel=20
                #        }
		#	else
		#	{
		#		  $trn = sprintf("$barewafid%04d", -$pnpY + 51*(66 - $pnpX));  # should calculate max row number, right now fixed for 4" Rebel=20
		#	}

       #my $trn = sprintf("$barewafid%04d", -$pnpY + 51*(66 - $pnpX));  # should calculate max row number, right now fixed for 4" Rebel=20
	my $bincat = $WFR1->GetDieField($dieset[0],"PartID");
        
		if($pnpBin > 0)
        {   # get just the bincat part
            $bincat =~ s/^$L0Part//;  # remove the L0 base part number section, which includes the -1
        }
#	elsif($pnpBin == 777)
#        {   
#             $bincat = "ORT";  #Maverick
#        }

		#elsif($pnpBin = "0" && $L0Part =~ /^(DCLFEX576503|DCLFEX576504|DCLFEX576505)/i) # Firdaus 20200130
		#{
		#	$bincat = "0000";
		#}
        else
        {
            $bincat = "FAIL";
        }
		
		if($bincat eq "FAIL" && $L0Part =~ /^(DCLFEX576503|DCLFEX576504|DCLFEX576505)/i) # Firdaus 20200130 LaserMarking for DualCurrent Setup 
		{
			$pnpBin = 999;
			$bincat = "0000";
		}
		
		
		$TrmBinCounts{$pnpBin}++;
		$TrmPartIDs{$pnpBin} = "$L1Part\_$bincat\_$OptionCodes";
		print TRM "$pnpDie\t$pnpX\t$pnpY\t$trn\t$pnpBin\t$L1Part\t$bincat\t$OptionCodes\n";
	}
	close TRM;
}


#sub MergeVISstep($) # ($VISstep e.g. T390 or T290)
#{
#	my $VISstep = shift;
#
#	#my %VISstep_score = (
#	#	"T390" => 8,
#	#	"T490" => 4,
#	#	"T590" => 2,
#	#	"T520" => 1 );
#	
#	if($VISready)
#	{   # FIXME: this code section doesn't really handle @diesets, it assumes 1 die / array location
#		#SIEWTY: Saber (START)
#		my $VISQuery = "SELECT TOP 1 sLot_ID, Submount_ID FROM bluedb.dbo.Saber_Tiles WHERE Submount_ID LIKE '$VISwaferid%' ";
#		#print "VISQuery = $VISQuery\n";
#		$rdx=0;
#		if($bluedb->Sql($VISQuery))  # select the records for this query
#		{   # if non-zero return then a SQL error has occurred.
#			print "Sql error: ".$bluedb->Error()." with query: $VISQuery\n";
#			return 0;
#		}
#		else
#		{
#			while($bluedb->FetchRow()) # until no more records, then zero val is returned.
#			{   # FetchRow() sets the initial record pointer to 1st rec then keeps incr
#				# get the currently pointed-to record's data
#				# $bluedb->FetchRow();
#				my %recdata = $bluedb->DataHash();  # col-names are case-sensitive
#				++$rdx;
#				$SaberLotID = $recdata{'sLot_ID'};
#				$SubmountID = $recdata{'Submount_ID'};
#				print "db\-$rdx: SaberLotID=$SaberLotID ; SubmountID=$SubmountID\n";
#			} #end while
#		}
#		my $VISpath = "$VISdir\\$SaberLotID\\WFR$SubmountID\-$VISstep\.vis";
#
#		my $LED = TesterParts2::GetLED($TesterType);
#		if ($VISstep eq "T590" && $LED eq "T590")
#		{
#			$VISpath = "$BurnDir\WFR$VISwaferid\-T590\.vis";  # alternate VISpath just for T590 (BI)
#		}
#		#print "VISpath = $VISpath\n";
#		#SIEWTY: Saber (END)
#
#	
#		if(-e $VISpath)
#		{
#			print "Merging VIS data from $VISpath\n";
#			open(VIS, $VISpath) || die "Can't open $VISpath for reading!\n";
#			my $VISheader = "H";
#			my @VISrecs = ();
#			while($VISheader =~ /^[A-Za-z].*/ || $VISheader =~ /^Row.*/) # old and new formats
#			{
#				$VISheader = <VIS>;
#				if($VISheader =~ /\S/)  # does it contain any non-white space characters?
#				{
#					if($VISheader !~ /^[A-Za-z].*/ && $VISheader !~ /^Row.*/)
#					{
#						last;  # First non-header record, saved in $VISheader for use below
#					}
#				}
#				else # an empty line or EOF has been hit right after the header section
#				{
#					for( $arr=0; $arr < $numArrayLeds; $arr++)
#					{
#					my ($aRow, $aCol) = ProductStructure::GetArrayRC($arr);
#					@dieset = ProductStructure::GetDieSet4Array($arr);
#					# add step score >0
#					$VIS_score{"$aRow\_$aCol"} += $VISstep_score{$VISstep};
#					}
#
#					
#					print "******** 1. $VISpath has no defects, not merging with $FullWFRpath ************\n";
#					print LOG "1. $VISpath has no defects, not merging with $FullWFRpath...\n";
#					return 1; 
#				}
#			}
#			# 1/3/07 Dima: a vis file may have one or more lines of headers (each starts
#			# with character H) followed by the table of results (row \t col \t defects)
#			@VISrecs = <VIS>;  # slurp the rest of the records
#			unshift @VISrecs, $VISheader;  # put the first record in the beginning of array
#			chomp @VISrecs; # remove newlines
#			close VIS;
#			my %VISrc2code = ();
#			for(my $vx= 0; $vx < scalar @VISrecs; $vx++)
#			{
#				# convert back-side view RC to front-side RC before storing code
#				my ($visrow, $viscol, @viscodearray) = split("\t", $VISrecs[$vx]); # pick up all viscodes
#				# Must ignore i<singleChar> informational Viscodes for the purposes of clearing the VISflag.
#				my @realcodes = ();
#				foreach my $vcode (@viscodearray)
#				{
#					if($vcode !~ /^i.*/)  # if not one of the iCodes
#					{
#						push(@realcodes, $vcode)
#					}
#				}
#				my $viscode = join('',@realcodes); # and combine in a single string
#				$viscode .= " ";                      # with a trailing space if more than 1 die maps into a single tile dev.
#				$viscol = int(($viscol-1) / $LedsPerLamp) + 1;  # 4 for AFL 1x4, 2 for AFL 1x2, 1 for everything else
#
#				# all of the following depends on proper setup of the NsxRow and NsxCol entries in the product structure
#				my $oldVisRC = "R$visrow"."C$viscol";  # same as tester Row, Col
#				my $visarray = ProductStructure::GetArray4NsxRC($oldVisRC); # convert visRC to array num
#				if(!defined $visarray) # Never let VISmap to WFR RC-mismatches slip through without logging.
#				{
#					print LOG "VIS file coordinates $oldVisRC do not exist in $FullWFRpath\n";
#					print "VIS file coordinates $oldVisRC do not exist in $FullWFRpath\n";
#					return 0;   # proceed no further, skips the WFR
#				}
#				my ($newVisRow, $newVisCol) = ProductStructure::GetArrayRC($visarray); # get aRow, aCol for array num
#				$VISrc2code{"R$newVisRow"."C$newVisCol"} .= $viscode;  # concatenated(for AFL)code is mapped into aRow aCol lookup table
#			}
#			for( $arr=0; $arr < $numArrayLeds; $arr++)
#			{
#				my ($aRow, $aCol) = ProductStructure::GetArrayRC($arr);
#				@dieset = ProductStructure::GetDieSet4Array($arr);
#				my $viscode = $VISrc2code{"R$aRow"."C$aCol"};   # the codes are mapped into aRow, aCol but only for this step
#
#				if($viscode =~ /\S/) 
#				{  # does viscode have any non-white space characters? yes
#					$WFR1->ReplaceDieFieldSet(@dieset,"VIScode_$VISstep",$viscode);   # we only populate the viscode section, no setting of VISflag yet
#					# add step score =0
#					$VIS_score{"$aRow\_$aCol"} += 0;
#				}
#				else # no codes for this step, so give it a passing score
#				{
#					# add step score >0
#					$VIS_score{"$aRow\_$aCol"} += $VISstep_score{$VISstep};
#				}
#			}
#			# for the purposes of Lumos, we add the Saber Lot ID which is usually different than the FST Lot
#			#$WFR1->AddHeaderField("LotName","SaberLot");
#			#my ($volume,$directories,$file) = File::Spec->splitpath($VISpath);
#			#my @dirparts = File::Spec->splitdir($directories);
#			#my $SaberLot = $dirparts[-2]; # because there is a trailing \ in $directories
#			#$WFR1->ReplaceHeaderField("SaberLot",$SaberLot,"SaberLot");
#			if($VISstep eq "T590")
#				{ 
#					# In order to remain the sLot ID in WFR file this is not required for T590 Burn In vis
#				}
#				else
#				{
#					$WFR1->AddHeaderField("LotName","SaberLot");
#					my ($volume,$directories,$file) = File::Spec->splitpath($VISpath);
#					my @dirparts = File::Spec->splitdir($directories);
#					my $SaberLot = $dirparts[-2]; # because there is a trailing \ in $directories
#					$WFR1->ReplaceHeaderField("SaberLot",$SaberLot,"SaberLot");
#				} 
#		}
#		else
#		{
#			print "******** 1.Can't find $VISpath, skipping  $FullWFRpath... ************\n";
#			print LOG "1.Can't find $VISpath, skipping $FullWFRpath...\n";
#			return 0;  # Simply not allowed for VIS data 
#		}
#	}
#
#	return 1;
#}


#		my $DieBinQuery = "SELECT tblEDCEOS.strBinNumber FROM bluedb.dbo.tblEDCEOS, bluedb.dbo.tblEDCEOSSubmount WHERE tblEDCEOS.strEOSID = tblEDCEOSSubmount.strEOSLotID AND tblEDCEOSSubmount.strEOSSubmount LIKE '$waferBin%'";
#		my $VISQuery = "SELECT TOP 1 sLot_ID, Submount_ID FROM Saber_Tiles WHERE Submount_ID LIKE '$VISwaferid%' ";
#		my $EPQuery = "SELECT TOP 1 sLot_ID, Submount_ID FROM Saber_Tiles WHERE Submount_ID LIKE '$VISwaferid%' ";
#		my $FWTQuery = "SELECT TOP 1 sLot_ID, Submount_ID_NoBin AS Submount_ID FROM Saber_Tiles WHERE Submount_ID LIKE '$VISwaferid%' ";


sub RJreport($) # ($reportdir)
{
	# Summarize rejects counts for this wafer.
	my $RJfilepath = "$_[0]/RJ_";
	my $barewafid = $WaferID;
	$barewafid =~ s/-$Iforce$//gi;
	$barewafid =~ s/-$VISpoststep$//gi;  # if it is there
	$barewafid =~ s/-Tj[0-9]{2,3}$//gi;  # if it is there
	$RJfilepath .= "$barewafid\.txt";
	
	
	print "RJ Rpt: $RJfilepath\n";
	Win32::File::SetAttributes($RJfilepath, NORMAL) if -e $RJfilepath;
	open(RJ,">$RJfilepath") || die "Can't open $RJfilepath for writing!\n";
	#print RJ "Lot#\tTile#\tBasePart#\tBinCat\tOptionCodes\tIforce\tBinStructure\tLED\tPhosphor\tQty\tPnPBin\n";
	#print RJ "Lot#\tTile#\tBinCat\tQty\n";
	
	my (%RJBinCounts, %RJPartIDs);
	for(my $ax=0; $ax < $numArrayLeds; $ax++)
	{
		IsArrayComplete($ax) || next;
		my $tsmDie = $ax + 1;
		@dieset = ProductStructure::GetDieSet4Array($ax);
		my $tsmPartID = $WFR1->GetDieField($dieset[0],"PartID");
		$RJBinCounts{$tsmPartID}++;
		$RJPartIDs{$tsmPartID} = $tsmPartID;
	}

	foreach my $tsmcountkey ( sort keys %RJPartIDs )
	{
		my $tsmcount = $RJBinCounts{$tsmcountkey};
		my $tsmBinCat = $RJPartIDs{$tsmcountkey};
		
		my $temptile = $WFR1->GetHeaderField('%Wafer');
		#my $tile = substr($temptile,1,9);
		my $tile = substr($temptile,1,10);
		
				
		#print RJ "$RawLotName\t$TileID\t$L1Part\t$tsmBinCat\t$OptionCodes\t$Iforce\t$BinStructure\t$LED\t$Phosphor\t$tsmcount\t$tsmcountkey\n";
		print RJ "$RawLotName\t$tile\t$tsmBinCat\t$tsmcount\t$barewafid\n";
	}
	close RJ
}

sub MergeVISstep($) # ($VISstep e.g. T390 or T290)
{
	my $VISstep = shift;
	if($VISready)
	{   # FIXME: this code section doesn't really handle @diesets, it assumes 1 die / array location

		#SIEWTY: Saber (START)
		#my $VISQuery = "SELECT TOP 1 sLot_ID, Submount_ID FROM bluedb.dbo.Saber_Tiles WHERE Submount_ID LIKE '$VISwaferid%' ";
		# Change reference to MES, because Singapore Saber database down
		my $VISQuery = "SELECT TOP 1 Pre_MESSmartLotID AS sLot_ID, Submount_ID FROM bluedb.dbo.MES_WO_Details WITH (NOLOCK) WHERE Submount_ID LIKE '$VISwaferid%' ";
		
		#Firdaus : update checking on saber
		# my $VISQuery = "SELECT TOP 1 A.strDF1SourceLot AS sLot_ID, B.strEOSSubmount AS Submount_ID FROM tblEDCEOS A WITH (NOLOCK), tblEDCEOSSubmount B WITH (NOLOCK) WHERE A.strEOSID = B.strEOSLotID AND B.strEOSSubmount LIKE '$VISwaferid%'";
		# print "VISQuery = $VISQuery\n";
		$rdx=0;

  		

		if($bluedb->Sql($VISQuery))  # select the records for this query
		{   # if non-zero return then a SQL error has occurred.
			print "Sql error: ".$bluedb->Error()." with query: $VISQuery\n";
			return 0;
		}
		else
		{
			while($bluedb->FetchRow()) # until no more records, then zero val is returned.
			{   # FetchRow() sets the initial record pointer to 1st rec then keeps incr
				# get the currently pointed-to record's data
				# $bluedb->FetchRow();
				my %recdata = $bluedb->DataHash();  # col-names are case-sensitive
				++$rdx;
				$SaberLotID = $recdata{'sLot_ID'};
				$SubmountID = $recdata{'Submount_ID'};
				print "db\-$rdx: SaberLotID=$SaberLotID ; SubmountID=$SubmountID\n";
			} #end while
		}

		my $VISpath = "$VISdir\\$SaberLotID\\WFR$SubmountID\-$VISstep\.vis";
		#print "VISpath = $VISpath\n";

		#SIEWTY: Saber (END)


 if ($VISstep eq "T390" || $VISstep eq "T490")
{
		
		if(-e $VISpath)
		{
			print "Merging VIS data from $VISpath\n";
			open(VIS, $VISpath) || die "Can't open $VISpath for reading!\n";
			my $VISheader = "H";
			my @VISrecs = ();
			while($VISheader =~ /^[A-Za-z].*/ || $VISheader =~ /^Row.*/) # old and new formats
			{
				$VISheader = <VIS>;
				if($VISheader !~ /^[A-Za-z].*/ && $VISheader !~ /^Row.*/)
				{
					last;  # First non-header record, saved in $VISheader for use below
				}
			}
			# 1/3/07 Dima: a vis file may have one or more lines of headers (each starts
			# with character H) followed by the table of results (row \t col \t defects)
			@VISrecs = <VIS>;  # slurp the rest of the records
			unshift @VISrecs, $VISheader;  # put the first record in the beginning of array
			chomp @VISrecs; # remove newlines
			close VIS;
			my %VISrc2code = ();
			for(my $vx= 0; $vx < scalar @VISrecs; $vx++)
			{
				# convert back-side view RC to front-side RC before storing code
				my ($visrow, $viscol, @viscodearray) = split("\t", $VISrecs[$vx]); # pick up all viscodes
				# Must ignore i<singleChar> informational Viscodes for the purposes of clearing the VISflag.
				my @realcodes = ();
				foreach my $vcode (@viscodearray)
				{
					if($vcode !~ /^i.*/)  # if not one of the iCodes
					{
						push(@realcodes, $vcode)
					}
				}
				my $viscode = join('',@realcodes); # and combine in a single string
				$viscode .= " ";                      # with a trailing space if more than 1 die maps into a single tile dev.
				$viscol = int(($viscol-1) / $LedsPerLamp) + 1;  # 4 for AFL 1x4, 2 for AFL 1x2, 1 for everything else

				# all of the following depends on proper setup of the NsxRow and NsxCol entries in the product structure
				my $oldVisRC = "R$visrow"."C$viscol";  # same as tester Row, Col
				my $visarray = ProductStructure::GetArray4NsxRC($oldVisRC); # convert visRC to array num
				if(!defined $visarray) # Never let VISmap to WFR RC-mismatches slip through without logging.
				{
					
                                   if ($VISstep eq "T290")
	  			  {
	  			          print LOG "VIS file coordinates $oldVisRC do not exist in $FullWFRpath\n";
					print "VIS file coordinates $oldVisRC do not exist in $FullWFRpath\n";
					return 1;   # optional
	  			  }
       				   if ($VISstep eq "T390")
	  			  {
			           	print LOG "VIS file coordinates $oldVisRC do not exist in $FullWFRpath\n";
					print "VIS file coordinates $oldVisRC do not exist in $FullWFRpath\n";
					return 0;   # proceed no further, skips the WFR
	 			  }
				}
				my ($newVisRow, $newVisCol) = ProductStructure::GetArrayRC($visarray); # get aRow, aCol for array num
				$VISrc2code{"R$newVisRow"."C$newVisCol"} .= $viscode;  # concatenated(for AFL)code is mapped into aRow aCol lookup table
			}
			for( $arr=0; $arr < $numArrayLeds; $arr++)
            {
                my ($aRow, $aCol) = ProductStructure::GetArrayRC($arr);
                @dieset = ProductStructure::GetDieSet4Array($arr);
                my $viscode = $VISrc2code{"R$aRow"."C$aCol"};   # the codes are mapped into aRow, aCol
                my @visflag = $WFR1->GetDieFieldSet(@dieset,"VISflag");  # always returns an array

                if($viscode =~ /\S/ && $visflag[0] == 1 )  # uninitialized viscode & visflag contains a space
                {  # does viscode have any non-white space characters? yes
                    $WFR1->ReplaceDieFieldSet(@dieset,"VISflag",0);
                    $WFR1->ReplaceDieFieldSet(@dieset,"VIScode_$VISstep",$viscode);
                }
                elsif($viscode =~ /\S/ && $visflag[0] == 0 )  # uninitialized visflag contains a space which also equals 0
                {  # does viscode have any non-white space characters? yes
                    $WFR1->ReplaceDieFieldSet(@dieset,"VISflag",0);
                    $WFR1->ReplaceDieFieldSet(@dieset,"VIScode_$VISstep",$viscode);
                }
                elsif($viscode !~ /\S/ && $visflag[0] eq " " )  # uninitialized viscode & visflag contains a space
                {   # does viscode have any non-white space characters? no
                    $WFR1->ReplaceDieFieldSet(@dieset,"VISflag",1);
                }
                elsif($viscode !~ /\S/ && $visflag[0] == 1 )  # uninitialized viscode contains a space
                {   # does viscode have any non-white space characters? no
                    $WFR1->ReplaceDieFieldSet(@dieset,"VISflag",1);
                }
            }
			# for the purposes of Lumos, we add the Saber Lot ID which is usually different than the FWT Lot
			$WFR1->AddHeaderField("LotName","SaberLot");
			my ($volume,$directories,$file) = File::Spec->splitpath($VISpath);
			my @dirparts = File::Spec->splitdir($directories);
			my $SaberLot = $dirparts[-2]; # because there is a trailing \ in $directories
			$WFR1->ReplaceHeaderField("SaberLot",$SaberLot,"SaberLot");
		}
		else
		    {
			print "******** 1.Can't find $VISpath, skipping  $FullWFRpath... ************\n";
			print LOG "1.Can't find $VISpath, skipping $FullWFRpath...\n";
			return 0;  # Simply not allowed for VIS data 
	    
		}
	
    }
}
		my $LED = TesterParts2::GetLED($TesterType);
		 
  		#if($VISprestep2 eq "T490" && $VISstep eq "T490" && $LED ne "T490")
  			#{
 			 # return 1;
			#}
		

		if ($VISstep eq "T590" && $LED eq "T590")
		{
			  my $VISpath2 = "$BurnDir\WFR$VISwaferid\-T590\.vis";

			if(-e $VISpath2)
		{
			print "Merging VIS data from $VISpath2\n";
			open(VIS, $VISpath2) || die "Can't open $VISpath2 for reading!\n";
			my $VISheader = "H";
			my @VISrecs = ();
			while($VISheader =~ /^[A-Za-z].*/ || $VISheader =~ /^Row.*/) # old and new formats
			{
				$VISheader = <VIS>;
				if($VISheader !~ /^[A-Za-z].*/ && $VISheader !~ /^Row.*/)
				{
					last;  # First non-header record, saved in $VISheader for use below
				}
			}
			# 1/3/07 Dima: a vis file may have one or more lines of headers (each starts
			# with character H) followed by the table of results (row \t col \t defects)
			@VISrecs = <VIS>;  # slurp the rest of the records
			unshift @VISrecs, $VISheader;  # put the first record in the beginning of array
			chomp @VISrecs; # remove newlines
			close VIS;
			my %VISrc2code = ();
			for(my $vx= 0; $vx < scalar @VISrecs; $vx++)
			{
				# convert back-side view RC to front-side RC before storing code
				my ($visrow, $viscol, @viscodearray) = split("\t", $VISrecs[$vx]); # pick up all viscodes
				# Must ignore i<singleChar> informational Viscodes for the purposes of clearing the VISflag.
				my @realcodes = ();
				foreach my $vcode (@viscodearray)
				{
					if($vcode !~ /^i.*/)  # if not one of the iCodes
					{
						push(@realcodes, $vcode)
					}
				}
				my $viscode = join('',@realcodes); # and combine in a single string
				$viscode .= " ";                      # with a trailing space if more than 1 die maps into a single tile dev.
				$viscol = int(($viscol-1) / $LedsPerLamp) + 1;  # 4 for AFL 1x4, 2 for AFL 1x2, 1 for everything else

				# all of the following depends on proper setup of the NsxRow and NsxCol entries in the product structure
				my $oldVisRC = "R$visrow"."C$viscol";  # same as tester Row, Col
				my $visarray = ProductStructure::GetArray4NsxRC($oldVisRC); # convert visRC to array num
				if(!defined $visarray) # Never let VISmap to WFR RC-mismatches slip through without logging.
				{
				
       				   if ($VISstep eq "T590")
	  			  {
			           	print LOG "VIS file coordinates $oldVisRC do not exist in $FullWFRpath\n";
					print "VIS file coordinates $oldVisRC do not exist in $FullWFRpath\n";
					return 0;   # proceed no further, skips the WFR
	 			  }
				}
				my ($newVisRow, $newVisCol) = ProductStructure::GetArrayRC($visarray); # get aRow, aCol for array num
				$VISrc2code{"R$newVisRow"."C$newVisCol"} .= $viscode;  # concatenated(for AFL)code is mapped into aRow aCol lookup table
			}
			for( $arr=0; $arr < $numArrayLeds; $arr++)
            {
                my ($aRow, $aCol) = ProductStructure::GetArrayRC($arr);
                @dieset = ProductStructure::GetDieSet4Array($arr);
                my $viscode = $VISrc2code{"R$aRow"."C$aCol"};   # the codes are mapped into aRow, aCol
                my @visflag = $WFR1->GetDieFieldSet(@dieset,"VISflag");  # always returns an array
		
                if($viscode =~ /\S/ && $visflag[0] == 1)  # uninitialized viscode & visflag contains a space
                {  # does viscode have any non-white space characters? yes
                    $WFR1->ReplaceDieFieldSet(@dieset,"VISflag",2);
                    $WFR1->ReplaceDieFieldSet(@dieset,"VIScode_$VISstep",$viscode);
                }
                elsif($viscode =~ /\S/ && $visflag[0] == 0 )  # uninitialized visflag contains a space which also equals 0
                {  # does viscode have any non-white space characters? yes
                    #$WFR1->ReplaceDieFieldSet(@dieset,"VISflag",2);
                    $WFR1->ReplaceDieFieldSet(@dieset,"VIScode_$VISstep",$viscode);
                }
		elsif($viscode =~ /\S/ && $visflag[0] != 0 )  # uninitialized visflag contains a space which also equals 0
                {  # does viscode have any non-white space characters? yes
                    $WFR1->ReplaceDieFieldSet(@dieset,"VISflag",2);
                    #$WFR1->ReplaceDieFieldSet(@dieset,"VIScode_$VISstep",$viscode);
                }
                elsif($viscode !~ /\S/ && $visflag[0] eq " " )  # uninitialized viscode & visflag contains a space
                {   # does viscode have any non-white space characters? no
                    $WFR1->ReplaceDieFieldSet(@dieset,"VISflag",1);
                }
                elsif($viscode !~ /\S/ && $visflag[0] == 1 )  # uninitialized viscode contains a space
                {   # does viscode have any non-white space characters? no
                    $WFR1->ReplaceDieFieldSet(@dieset,"VISflag",1);
                }
            }
            # In order to remain the sLot ID in WFR file this is not required for T590 Burn In vis files HY 22Mar'15
            # # for the purposes of Lumos, we add the Saber Lot ID which is usually different than the FWT Lot
        	# $WFR1->AddHeaderField("LotName","SaberLot"); # will issue warning if attempted more than once for same WFR
            # my ($volume,$directories,$file) = File::Spec->splitpath($VISpath2);
            # my @dirparts = File::Spec->splitdir($directories);
            # my $SaberLot = $dirparts[-2]; # because there is a trailing \ in $directories
            # $WFR1->ReplaceHeaderField("SaberLot",$SaberLot,"SaberLot");
        }
        else
        {
            print "******** Can't find any version of $VISpath2, skipping this WFR... ************\n";
            print LOG "Can't find any version of $VISpath2, skipping $FullWFRpath...\n";

		if ($VISstep eq "T590")
		{
			# Trigger MS SQL to perform backend correction data
			my $SQLQuery1 = "INSERT INTO MYGBYNBYN1MS009.MapsDB.dbo.Backend_Trigger_Correction (fFileName, ProcessGroup, tDateTime) VALUES ('$VISpath2','T590 RELOAD', GETDATE())";
			print "SQLQuery1: $SQLQuery1\n";
			if($bluedb->Sql($SQLQuery1))  # execute this query
			{   # if non-zero return then a SQL error has occurred.
				print "Sql error: ".$bluedb->Error()." with query: $SQLQuery1\n";
				return 0;
			}
		}

            return 0;
        }

}

	return 1;
}

sub MergeEPstep($) # ($VISstep Epoxy merging)
{
	my $VISstep = shift;
	if($VISready)
	{   
		#SIEWTY: Saber (START)
		#my $EPQuery = "SELECT TOP 1 sLot_ID, Submount_ID FROM bluedb.dbo.Saber_Tiles WHERE Submount_ID LIKE '$VISwaferid%' ";
		my $EPQuery = "SELECT TOP 1 Pre_MESSmartLotID  AS sLot_ID, Submount_ID FROM bluedb.dbo.MES_WO_Details WITH (NOLOCK) WHERE Submount_ID LIKE '$VISwaferid%' ";
		#print "EPQuery = $EPQuery\n";
		$rdx=0;

		if($bluedb->Sql($EPQuery))  # select the records for this query
		{   # if non-zero return then a SQL error has occurred.
			print "Sql error: ".$bluedb->Error()." with query: $EPQuery\n";
			return 0;
		}
		else
		{
			while($bluedb->FetchRow()) # until no more records, then zero val is returned.
			{   # FetchRow() sets the initial record pointer to 1st rec then keeps incr
				# get the currently pointed-to record's data
				# $bluedb->FetchRow();
				my %recdata = $bluedb->DataHash();  # col-names are case-sensitive
				++$rdx;
				$SaberLotID = $recdata{'sLot_ID'};
				$SubmountID = $recdata{'Submount_ID'};
			} #end while
		}

		my $VISpath = "$VISdir\\$SaberLotID\\WFR$SubmountID\-$VISstep";
		#print "EPpath = $VISpath\n";

		#SIEWTY: Saber (END)

		if(-e $VISpath)
		{
			print "Merging EP data from $VISpath\n";
			open(VIS, $VISpath) || die "Can't open $VISpath for reading!\n";
			my $VISheader = "H";
			my @VISrecs = ();
			while($VISheader =~ /^[A-Za-z].*/ || $VISheader =~ /^Row.*/) # old and new formats
			{
				$VISheader = <VIS>;
				if($VISheader !~ /^[A-Za-z].*/ && $VISheader !~ /^Row.*/)
				{
					last;  # First non-header record, saved in $VISheader for use below
				}
			}
			@VISrecs = <VIS>;  # slurp the rest of the records
			unshift @VISrecs, $VISheader;  # put the first record in the beginning of array
			chomp @VISrecs; # remove newlines
			close VIS;
			my %VISrc2code = ();
			for(my $vx= 0; $vx < scalar @VISrecs; $vx++)
			{
				# convert back-side view RC to front-side RC before storing code
				my ($visrow, $viscol, @viscodearray) = split("\t", $VISrecs[$vx]); # pick up all viscodes
				my (@EPrecs) = split("\t", $VISrecs[$vx]);
				my  $VISrecs1 = $EPrecs[4];
				my  $VISrecs2 = $EPrecs[5];
				my  $VISrecs3 = $EPrecs[6];
				my  $VISrecs4 = $EPrecs[7];

				my $averageVis = ( $VISrecs1 + $VISrecs2 + $VISrecs3 + $VISrecs4 ) /4;
				my $viscode =  "$VISrecs1\t$VISrecs2\t$VISrecs3\t$VISrecs4\t$averageVis";
				$viscode =~ s/ //g;     # remove any embedded spaces
				$viscol = int(($viscol-1) / $LedsPerLamp) + 1;  # 4 for AFL 1x4, 2 for AFL 1x2, 1 for everything else

				# all of the following depends on proper setup of the NsxRow and NsxCol entries in the product structure
				my $oldVisRC = "R$visrow"."C$viscol";  # same as tester Row, Col
				my $visarray = ProductStructure::GetArray4NsxRC($oldVisRC); # convert visRC to array num
				if(!defined $visarray) # Never let VISmap to WFR RC-mismatches slip through without logging.
				{
					print LOG "VIS EP file coordinates $oldVisRC do not exist in $FullWFRpath\n";
					print "VIS EP file coordinates $oldVisRC do not exist in $FullWFRpath\n";
					return 0;   # proceed no further, skips the WFR
				}
				my ($newVisRow, $newVisCol) = ProductStructure::GetArrayRC($visarray); # get aRow, aCol for array num
				$VISrc2code{"R$newVisRow"."C$newVisCol"} .= $viscode;  # concatenated(for AFL)code is mapped into aRow aCol lookup table
			}
			for( $arr=0; $arr < $numArrayLeds; $arr++)
			{
				my ($aRow, $aCol) = ProductStructure::GetArrayRC($arr);
				@dieset = ProductStructure::GetDieSet4Array($arr);
				my $viscode = $VISrc2code{"R$aRow"."C$aCol"};   # the codes are mapped into aRow, aCol
				my @visflag = $WFR1->GetDieFieldSet(@dieset,"VISflag");  # always returns an array
				if($viscode =~ /^[0-9].*/)  # uninitialized viscode & visflag contains a space
				{
					my ($viscode1,$viscode2,$viscode3,$viscode4,$viscode5) = split("\t", $viscode);
					$WFR1->ReplaceDieFieldSet($dieset[0],"Epoxy_Bottom", $viscode1);
					$WFR1->ReplaceDieFieldSet($dieset[0],"Epoxy_Right", $viscode2);
					$WFR1->ReplaceDieFieldSet($dieset[0],"Epoxy_Top", $viscode3);
					$WFR1->ReplaceDieFieldSet($dieset[0],"Epoxy_Left", $viscode4);
					$WFR1->ReplaceDieFieldSet($dieset[0],"Epoxy_Average", $viscode5);
				}
				else
				{
					$WFR1->ReplaceDieFieldSet($dieset[0],"Epoxy_Bottom", 0);
					$WFR1->ReplaceDieFieldSet($dieset[0],"Epoxy_Right", 0);
					$WFR1->ReplaceDieFieldSet($dieset[0],"Epoxy_Top", 0);
					$WFR1->ReplaceDieFieldSet($dieset[0],"Epoxy_Left", 0);
					$WFR1->ReplaceDieFieldSet($dieset[0],"Epoxy_Average", 0);
				}
			}
		}
		else
		{
			print "******** 2.Can't find $VISpath, skipping this EP merge... ************\n";
			print LOG "2.Can't find $VISpath, skipping EP Merge for $FullWFRpath...\n";
			return 1;  # SKip the merging if can't find the file, this is optional
		}
	}
	return 1;
}

sub MergeFWTstep($) # (Merge with Post Saber Test)
{
    my $VISstep = shift;
    if($VISready)
    {
        #SIEWTY: Saber (START)
		# Note: this query is different than the others because -B# is dropped in the PostSaber Raw WFR*.blu filename
		# my $FWTQuery = "SELECT TOP 1 sLot_ID, Submount_ID_NoBin AS Submount_ID FROM bluedb.dbo.Saber_Tiles WHERE Submount_ID LIKE '$VISwaferid%' ";
		my $FWTQuery = "SELECT TOP 1 Pre_MESSmartLotID AS sLot_ID, Submount_ID_NoBin FROM bluedb.dbo.MES_WO_Details WITH (NOLOCK) WHERE Submount_ID LIKE '$VISwaferid%' ";
		#print "FWTQuery = $FWTQuery\n";
		$rdx=0;
		
		if($bluedb->Sql($FWTQuery))  # select the records for this query
        {   # if non-zero return then a SQL error has occurred.
            print "Sql error: ".$bluedb->Error()." with query: $FWTQuery\n";
		    return 0;
        }
        else
		{
            while($bluedb->FetchRow()) # until no more records, then zero val is returned.
            {   # FetchRow() sets the initial record pointer to 1st rec then keeps incr
                # get the currently pointed-to record's data
                # $bluedb->FetchRow();
                my %recdata = $bluedb->DataHash();  # col-names are case-sensitive
                ++$rdx;
				$SaberLotID = $recdata{'sLot_ID'};
				$SubmountID = $recdata{'Submount_ID'};
				print "db\-$rdx: SaberLotID=$SaberLotID ; SubmountID=$SubmountID\n";
            } #end while
		}
		
		$FWTpostest = "T390_$Iforce.blu";
		
		$SubmountID = substr($SubmountID,0,10);  # make sure the -Pnnn diebin is stripped off.
		
		my $VISpath = "$PostSaberfolder\\$SaberLotID\\WFR$SubmountID\-$FWTpostest";
		#print "FWTpath  = $VISpath\n";
		#SIEWTY: Saber (END)
	
        if(-e $VISpath)
        {
            print "Merging Post-Saber FWT data from $VISpath\n";
            open(VIS, $VISpath) || die "Can't open $VISpath for reading!\n";
            my $VISheader = "%";
            my $content = <VIS>;
            my @VISrecs = ();

            while($VISheader =~ /^[A-Za-z].*/ || $VISheader =~ /^Row.*/ || $VISheader =~ /^%.*/) # old and new formats
            {
                $VISheader = <VIS>;
                if($VISheader !~ /^[A-Za-z].*/ && $VISheader !~ /^Row.*/ && $VISheader !~ /^%.*/)
                {
                    last;  # First non-header record, saved in $VISheader for use below
                }
            }
            # with character %) followed by the table of results (row \t col \t defects)
            @VISrecs = <VIS>;  # slurp the rest of the records
            unshift @VISrecs, $VISheader;  # put the first record in the beginning of array
            chomp @VISrecs; # remove newlines
            close VIS;
            my %VISrc2code = ();
		my %VISrc2code2 = ();
            for(my $vx= 0; $vx < scalar @VISrecs; $vx++)
            {
                my ($na,$visrow, $viscol, @viscodearray) = split("\t", $VISrecs[$vx]); # pick up all viscodes
                my ($A,$B,$C,$D,$E,$F,$G,$H,$I,$J,$K,$L,$M,$N,$O,$P,$Q,$NA) = split("\t", $VISrecs[$vx]);
                my $viscode =  "$P"; # PHIe
				my $viscode1 =  "$N"; # Lpk
				$viscode =~ s/ //g;     # remove any embedded spaces
 				$viscode1 =~ s/ //g;     # remove any embedded spaces
                $viscol = int(($viscol-1) / $LedsPerLamp) + 1;  # 4 for AFL 1x4, 2 for AFL 1x2, 1 for everything else

                # all of the following depends on proper setup of the NsxRow and NsxCol entries in the product structure
                my $oldVisRC = "R$visrow"."C$viscol";  # same as tester Row, Col
                my $visarray = ProductStructure::GetArray4NsxRC($oldVisRC); # convert visRC to array num
                if(!defined $visarray) # Never let VISmap to WFR RC-mismatches slip through without logging.
                {
                    print LOG "VIS FWT file coordinates $oldVisRC do not exist in $FullWFRpath\n";
                    print "VIS FWT file coordinates $oldVisRC do not exist in $FullWFRpath\n";
                    return 0;   # proceed no further, skips the WFR
                }
                my ($newVisRow, $newVisCol) = ProductStructure::GetArrayRC($visarray); # get aRow, aCol for array num
                $VISrc2code{"R$newVisRow"."C$newVisCol"} .= $viscode;  # concatenated(for AFL)code is mapped into aRow aCol lookup table
			$VISrc2code2{"R$newVisRow"."C$newVisCol"} .= $viscode1;
		}
	    #my $vx;
	    #my ($A,$B,$C,$D,$E,$F,$G,$H,$I,$J,$K,$L,$M,$N,$O,$P,$Q,$NA) = split("\t", $VISrecs[$vx]);
	    #my $viscodel =  "$N";
	    
            for( $arr=0; $arr < $numArrayLeds; $arr++)
            {
                
		#my $vx;
	    #my ($A,$B,$C,$D,$E,$F,$G,$H,$I,$J,$K,$L,$M,$N,$O,$P,$Q,$NA) = split("\t", $VISrecs[$vx]);
	    #my $viscodel =  "$N";		
		
		my ($aRow, $aCol) = ProductStructure::GetArrayRC($arr);
                @dieset = ProductStructure::GetDieSet4Array($arr);
                my $viscode = $VISrc2code{"R$aRow"."C$aCol"};   # the codes are mapped into aRow, aCol
		my $viscode1 = $VISrc2code2{"R$aRow"."C$aCol"};   # the codes are mapped into aRow, aCol
                my @visflag = $WFR1->GetDieFieldSet(@dieset,"VISflag");  # always returns an array

                if($viscode =~ /\S/ && $visflag[0] == 1 )  # uninitialized viscode & visflag contains a space
                {  # does viscode have any non-white space characters? yes
					$WFR1->ReplaceDieFieldSet(@dieset,"PostSaberFWT_PHIe",$viscode);
					$WFR1->ReplaceDieFieldSet(@dieset,"PostSaber_Lpk",$viscode1);
                }
                elsif($viscode =~ /\S/ && $visflag[0] == 0 )  # uninitialized visflag contains a space which also equals 0
                {  # does viscode have any non-white space characters? yes
                    $viscode =~ s/ //g;   # remove any embedded spaces
					# $WFR1->ReplaceDieFieldSet(@dieset,"PostSaberFWT_PHIe",$viscode);
                }
                elsif($viscode !~ /\S/ && $visflag[0] eq " " )  # uninitialized viscode & visflag contains a space
                {   # does viscode have any non-white space characters? no
                    $viscode =~ s/ //g;   # remove any embedded spaces
                    # $WFR1->ReplaceDieFieldSet(@dieset,"PostSaberFWT_PHIe",$viscode);
                }
                elsif($viscode !~ /\S/ && $visflag[0] == 1 )  # uninitialized viscode contains a space
                {   # does viscode have any non-white space characters? no
					#  $viscode =~ s/ //g;     # remove any embedded spaces
                   $WFR1->ReplaceDieFieldSet(@dieset,"PostSaberFWT_PHIe",$viscode);
		   $WFR1->ReplaceDieFieldSet(@dieset,"PostSaber_Lpk",$viscode1);
                }
            }
        }
        else
        {
            print "******** 3.Can't find $VISpath, skipping this PostSaber merge... ************\n";
            print LOG "3.Can't find $VISpath, skipping PostSaber merge for $FullWFRpath...\n";
            return 1;  # SKip the merging if can't find the file, this is optional
        }
    }
    return 1;
}

sub GetDieBin($)
{	# Use the BlueDB to find the DieBin this tile was built with
	my $waferBin = "$_[0]";
	# print "WaferBIN1 == $waferBin\n";
	$waferBin =~ s/-$Iforce$//gi;
	$waferBin =~ s/-$VISpoststep$//gi;  # if it is there
	$waferBin =~ s/-Tj[0-9]{2,3}$//gi;  # if it is there
	$rdx=0;
	
	# Check W.O. and Lot info against BlueDB records given the cleaned-up WaferID found above

	my $DieBinQuery = "SELECT B.BIN AS BinNo
				FROM bluedb.dbo.tblEDCEOSSubmount A, bluedb.dbo.MES_WO_Details B WITH (NOLOCK)
				WHERE A.strEOSSubmount = B.Submount_ID 
				AND A.strEOSSubmount LIKE '$waferBin\%'";

	#my $DieBinQuery =
	#	# From Siew, but only works for Sabered tiles. 4/8/2011
	#	"SELECT TOP 1 BinNo = CASE LEN(RIGHT(Submount_ID,LEN(Submount_ID)-CHARINDEX('-',Submount_ID,8)))
	#		  WHEN 2
	#				THEN RIGHT(Submount_ID,LEN(Submount_ID)-CHARINDEX('-',Submount_ID,8))
	#		  WHEN 3
	#				THEN RIGHT(Submount_ID,LEN(Submount_ID)-CHARINDEX('-',Submount_ID,8))
	#		  WHEN 4
	#				THEN RIGHT(Submount_ID,LEN(Submount_ID)-CHARINDEX('-',Submount_ID,8))
	#		  ELSE
	#				''
	#		  END
	#	FROM bluedb.dbo.MES_WO_Details WITH (NOLOCK)
	#	#FROM BlueDB.dbo.Saber_Tiles
	#	WHERE Submount_ID LIKE '$waferBin\%'";

	my $dbDieBin = "NA";
	if($bluedb->Sql($DieBinQuery))  # select the records for this query
	{   # if non-zero return then a SQL error has occurred.
		print LOG "Sql error: ".$bluedb->Error()." with query: \n$DieBinQuery\n";
		print     "Sql error: ".$bluedb->Error()." with query: \n$DieBinQuery\n";
		#return 0;
	}
	else
	{
		my $rdx=0;
		while($bluedb->FetchRow()) # until no more records, then zero val is returned.
		{   # FetchRow() sets the initial record pointer to 1st rec then keeps incr
			# get the currently pointed-to record's data
			my %recdata = $bluedb->DataHash();  # col-names are case-sensitive
			++$rdx;
			
			$dbDieBin = $recdata{'BinNo'};
			undef %recdata;  # undef if we have no further use of this hash.
		}
		if($rdx == 0)
		{
			print LOG "***No SubmountID or LOT info for $WaferID in BlueDB!***\n";
			print     "***No SubmountID or LOT info for $WaferID in BlueDB!***\n";
			$DieBin = $dbDieBin;
			#return 0;  # processing stops for this wafer
		}
		elsif($rdx > 1)
		{
			print LOG "***More than 1 \($rdx\) SubmountID/Lot for $WaferID in BlueDB!***\n";
			print     "***More than 1 \($rdx\) SubmountID/Lot for $WaferID in BlueDB!***\n";
			#return 0;  # processing stops for this wafer
		}
	}
	$DieBin = $dbDieBin;
	print "Tile DieBin = $DieBin\n";
	return 1;
}

sub GetMESLotID()
{	# Use the BlueDB to find the MESLotID for this tile
	$rdx=0;
	$MESLotID = "";
	my $MESLotIDQuery = "SELECT strDF1SourceLot as MESLOT FROM bluedb.dbo.tblEDCEOS WHERE strEOSID = \'$RawLotName\'";
	#print "MESLotIDQuery = $MESLotIDQuery\n";

	if($bluedb->Sql($MESLotIDQuery))  # select the records for this query
	{   # if non-zero return then a SQL error has occurred.
		#** Need to defined what is the lot id
		print "Sql error: ".$bluedb->Error()." with query: $MESLotIDQuery \n";
		$MESLotID = "";
		return 0;
	}
	else
	{
		while($bluedb->FetchRow()) # until no more records, then zero val is returned.
		{   # FetchRow() sets the initial record pointer to 1st rec then keeps incr
			# get the currently pointed-to record's data
			my %recdata = $bluedb->DataHash();  # col-names are case-sensitive
			++$rdx;
			$MESLotID = $recdata{'MESLOT'};
			print "db\-$rdx: MESLotID=$MESLotID\n";
		} 
	}  #end else

	$MESLotID =~ s/ //g;     # remove any embedded spaces
	$MESLotID = uc $MESLotID;   # ensure upper case
	print "MESLotID = $MESLotID for TesterLot = $RawLotName\n";
	return 1;
}
